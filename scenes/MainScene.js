// scenes/MainScene.js - Ê®™ÁâàÂç∑ËΩ¥ÂÖ≥Âç°Á≥ªÁªü

// üîß ‰ΩøÁî®ÂÖ®Â±ÄÁ±ªÔºåÈÅøÂÖçÈáçÂ§çÂ£∞Êòé
// Enemy Âíå EnemyBullet Á±ªÂ∑≤Âú® EnemyClass.js Âíå EnemyBullet.js ‰∏≠ÂÆö‰πâ

// üîß ‰ΩøÁî®ÂÖ®Â±ÄÁ±ªÔºåÈÅøÂÖçÈáçÂ§çÂ£∞Êòé
// Weapon Âíå Bullet Á±ªÂ∑≤Âú® Weapon.js Âíå Bullet.js ‰∏≠ÂÆö‰πâ

class MainScene extends Phaser.Scene {
    constructor() {
        super('MainScene');
    }

    init(data) {
        console.log('MainScene: ÂàùÂßãÂåñÔºåÊé•Êî∂Âà∞ÁöÑÊï∞ÊçÆ:', data);
        this.selectedPlayer = data.player || null;
        this.currentLevelIndex = data.level || 0; // üÜï Êé•Êî∂ÂÖ≥Âç°Á¥¢Âºï
        console.log('MainScene: ÈÄâ‰∏≠ÁöÑÁé©ÂÆ∂:', this.selectedPlayer);
        console.log('MainScene: ÂΩìÂâçÂÖ≥Âç°Á¥¢Âºï:', this.currentLevelIndex);
    }

    create() {
        console.log('MainScene: ÂàõÂª∫Ê®™ÁâàÂç∑ËΩ¥Âú∫ÊôØÂºÄÂßã');
        
        // üîß Ê∏ÖÁêÜÂèØËÉΩÂ≠òÂú®ÁöÑÊóß‰∫ã‰ª∂ÁõëÂê¨Âô®ÔºàÈò≤Ê≠¢ÈáçÂ§çÊ∑ªÂä†Ôºâ
        this.input.keyboard.removeAllListeners();
        this.events.off('enemyDied');
        this.events.off('enemyEscaped');
      
        // üìä ÂàùÂßãÂåñÁªüËÆ°Á≥ªÁªü
        if (window.StatsManager) {
            window.StatsManager.init();
        }
        
        // üèÜ ÂàùÂßãÂåñÊàêÂ∞±Á≥ªÁªü
        if (window.AchievementManager) {
            window.AchievementManager.init();
        }
        
        // üíæ Âä†ËΩΩÊ∏∏ÊàèÊï∞ÊçÆ
        if (window.SaveManager) {
            window.SaveManager.loadAll();
        }
      
        // üé® ÂàùÂßãÂåñÂÉèÁ¥†Ëâ∫ÊúØÁ≥ªÁªü
        this.pixelArtSystem = new PixelArtSystem(this);
        this.pixelArtSystem.initAllTextures();
      
        // üîä ÂàùÂßãÂåñÈü≥ÊïàÁ≥ªÁªü
        this.audioManager = new AudioManager(this);
      
        // üÜï Âä†ËΩΩÂΩìÂâçÂÖ≥Âç°ÈÖçÁΩÆ
        this.loadLevelConfig();
      
        // Ê≠¶Âô®Á≥ªÁªüÂàùÂßãÂåñ
        this.initWeaponSystem();
      
        // üÜï ÂÖ≥Âç°Á≥ªÁªüÂàùÂßãÂåñ
        this.initLevelSystem();
      
        // ÂàùÂßãÂåñË°ÄÈáèÁ≥ªÁªü
        this.initHealthSystem();
  
        // üé® ÂàùÂßãÂåñËÉåÊôØÁÆ°ÁêÜÂô®
        this.backgroundManager = new BackgroundManager(this);
        this.backgroundManager.createLevelBackground();
  
        // üÜï Ê®™ÁâàÂç∑ËΩ¥ÔºöËÆæÁΩÆÊâ©Â±ïÁöÑ‰∏ñÁïåËæπÁïå
        console.log(`üåç ËÆæÁΩÆÊ®™ÁâàÂç∑ËΩ¥‰∏ñÁïåËæπÁïå: ${GAME_CONFIG.WORLD_WIDTH}x${GAME_CONFIG.WORLD_HEIGHT}`);
        this.physics.world.setBounds(0, 0, GAME_CONFIG.WORLD_WIDTH, GAME_CONFIG.WORLD_HEIGHT);
        
        // üÜï Ê®™ÁâàÂç∑ËΩ¥ÔºöËÆæÁΩÆÊëÑÂÉèÊú∫ËæπÁïåÂíåË∑üÈöèÁ≥ªÁªü
        this.cameras.main.setBounds(0, 0, GAME_CONFIG.WORLD_WIDTH, GAME_CONFIG.WORLD_HEIGHT);
        console.log('üìπ ÊëÑÂÉèÊú∫ËæπÁïåËÆæÁΩÆÂÆåÊàê');
  
        // üÜï ÂàõÂª∫ÂÖ≥Âç°ÂØπÂ∫îÁöÑÁé©ÂÆ∂
        this.createLevelPlayer();
  
        // ÂàõÂª∫Ê∏∏ÊàèÂØπË±°ÁªÑ
        this.bullets = this.physics.add.group({
            classType: Bullet,
            maxSize: 50
        });
  
        this.enemies = this.physics.add.group({
            classType: window.Enemy, // üîß ‰ΩøÁî® window.Enemy
            maxSize: 20
        });
      
        // üÜï Êïå‰∫∫Â≠êÂºπÁªÑ
        this.enemyBullets = this.physics.add.group({
            classType: window.EnemyBullet, // üîß ‰ΩøÁî® window.EnemyBullet
            maxSize: 30
        });
      
        // ÂàõÂª∫Á≤íÂ≠êÊïàÊûúÁ≥ªÁªü
        this.createParticleSystems();
  
        // üÜï Á¢∞ÊíûÊ£ÄÊµãÔºàÂ¢ûÂä†Êïå‰∫∫Â≠êÂºπÔºâ
        this.physics.add.overlap(this.bullets, this.enemies, this.handleBulletHit, null, this);
        this.physics.add.collider(this.player, this.enemies, this.handlePlayerHit, null, this);
        this.physics.add.overlap(this.player, this.enemyBullets, this.handleEnemyBulletHit, null, this);
  
        // üÜï ÂàùÂßãÂåñËß¶Êë∏ÊéßÂà∂Á≥ªÁªü
        this.touchControls = new TouchControls(this);
        this.touchControls.create();

        // ËæìÂÖ•ÊéßÂà∂
        this.cursors = this.input.keyboard.createCursorKeys();
        
        // Ê∑ªÂä†WASDÈîÆÊîØÊåÅ
        this.wasdKeys = this.input.keyboard.addKeys({
            W: Phaser.Input.Keyboard.KeyCodes.W,
            A: Phaser.Input.Keyboard.KeyCodes.A,
            S: Phaser.Input.Keyboard.KeyCodes.S,
            D: Phaser.Input.Keyboard.KeyCodes.D
        });
        
        this.input.on('pointerdown', this.shoot, this);
        this.input.keyboard.on('keydown-SPACE', this.shoot, this);
        this.input.keyboard.on('keydown-P', this.togglePause, this);
        
        // üÜï Ê≠¶Âô®ÂàáÊç¢ÊåâÈîÆ
        this.input.keyboard.on('keydown-ONE', () => this.switchWeapon(0), this);
        this.input.keyboard.on('keydown-TWO', () => this.switchWeapon(1), this);
        this.input.keyboard.on('keydown-THREE', () => this.switchWeapon(2), this);
        this.input.keyboard.on('keydown-FOUR', () => this.switchWeapon(3), this);
        this.input.keyboard.on('keydown-FIVE', () => this.switchWeapon(4), this);
        this.input.keyboard.on('keydown-SIX', () => this.switchWeapon(5), this);
        
        // üåç ÂàùÂßãÂåñÈ´òÁ∫ßÂú∫ÊôØÁ≥ªÁªü
        this.advancedSceneManager = new AdvancedSceneManager(this);
        
        // üåç ÂàùÂßãÂåñÂú∫ÊôØÂàáÊç¢Âô®
        this.sceneSwitcher = new SceneSwitcher(this);
        
        // üåç Ê∑ªÂä†Âú∫ÊôØÂàáÊç¢Âø´Êç∑ÈîÆ
        this.sceneKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.M);
        
        // üåç ÈªòËÆ§Âä†ËΩΩÁ¨¨‰∏Ä‰∏™Âú∫ÊôØ
        this.advancedSceneManager.loadScene('inside_golem');
        
        // ÂÖ®Â±ÄRÈîÆÁõëÂê¨Âô®ÔºàÁî®‰∫éÈáçÊñ∞ÂºÄÂßãÊ∏∏ÊàèÔºâ
        this.input.keyboard.on('keydown-R', this.handleRestart, this);
        
        // ÂàùÂßãÂåñÈü≥È¢ë‰∏ä‰∏ãÊñáÔºàËß£ÂÜ≥AudioContextË≠¶ÂëäÔºâ
        this.input.once('pointerdown', () => {
            if (this.sound && this.sound.context && this.sound.context.state === 'suspended') {
                this.sound.context.resume();
                console.log('MainScene: Èü≥È¢ë‰∏ä‰∏ãÊñáÂ∑≤ÊÅ¢Â§ç');
            }
        });
  
        // üìä ÂàùÂßãÂåñUIÁÆ°ÁêÜÂô®
        this.uiManager = new UIManager(this);
        this.uiManager.createHUD();
  
        // üîß Ê∑ªÂä†Êïå‰∫∫Ê≠ª‰∫°‰∫ã‰ª∂ÁõëÂê¨Âô®
        this.events.on('enemyDied', this.handleEnemyDeath, this);
        this.events.on('enemyEscaped', this.handleEnemyEscape, this);
  
        // üÜï ÊòæÁ§∫ÂÖ≥Âç°ÂºÄÂú∫Âä®ÁîªÔºàÂú®ÊâÄÊúâÂÖÉÁ¥†ÂàõÂª∫ÂÆåÊàêÂêéÔºâ
        this.showLevelIntro();
  
        // üÜï ÂºÄÂßãÂÖ≥Âç°ÁâπÂÆöÁöÑÊïå‰∫∫ÁîüÊàêÔºàÂú®‰ªãÁªçÁªìÊùüÂêéÔºâ
        this.time.delayedCall(3500, () => {
            this.startLevelEnemySpawner();
        });

        // ÊòæÁ§∫ÁâàÊú¨‰ø°ÊÅØ
        this.add.text(1200, 700, 'v4.1-SideScroll', { 
            font: '14px Arial', 
            fill: '#666666' 
        }).setOrigin(1).setScrollFactor(0); // üÜï Âõ∫ÂÆöÊòæÁ§∫
    
        console.log('MainScene: Ê®™ÁâàÂç∑ËΩ¥Âú∫ÊôØÂàõÂª∫ÂÆåÊàê');

        // ËÆæÁΩÆÂàùÂßãÁßØÂàÜ‰∏∫5000
        this.score = 5000;

        this.powerUpManager = new window.PowerUpManager(this);
        // Áé©ÂÆ∂‰∏éÈÅìÂÖ∑Á¢∞ÊíûÊ£ÄÊµã
        this.physics.add.overlap(this.player, this.powerUpManager.powerUps, this.collectPowerUp, null, this);

        // üÜï ÂàùÂßãÂåñÈöúÁ¢çÁâ©Á≥ªÁªü
        this.obstacleManager = new window.ObstacleManager(this);
        this.obstacleManager.setLevel('forest');
        this.obstacleManager.spawnObstacles();
    }

    // üÜï ÂàùÂßãÂåñÊ≠¶Âô®Á≥ªÁªü
    initWeaponSystem() {
        this.lastShootTime = 0;
        
        // üîß ‰ΩøÁî®ÈÖçÁΩÆÊñá‰ª∂ÂàõÂª∫Ê≠¶Âô®
        this.weapons = [
            new Weapon(
                WEAPON_CONFIGS.AK47.name,
                WEAPON_CONFIGS.AK47.damage,
                WEAPON_CONFIGS.AK47.fireRate,
                WEAPON_CONFIGS.AK47.bulletSpeed,
                WEAPON_CONFIGS.AK47.bulletSize,
                WEAPON_CONFIGS.AK47.bulletColor,
                WEAPON_CONFIGS.AK47.texture,
                WEAPON_CONFIGS.AK47.burstCount,
                WEAPON_CONFIGS.AK47.burstDelay,
                WEAPON_CONFIGS.AK47.bulletCost,
                WEAPON_CONFIGS.AK47.specialEffect,
                WEAPON_CONFIGS.AK47.isContinuous,
                WEAPON_CONFIGS.AK47.duration,
                WEAPON_CONFIGS.AK47.config
            ),
            new Weapon(
                WEAPON_CONFIGS.DESERT_EAGLE.name,
                WEAPON_CONFIGS.DESERT_EAGLE.damage,
                WEAPON_CONFIGS.DESERT_EAGLE.fireRate,
                WEAPON_CONFIGS.DESERT_EAGLE.bulletSpeed,
                WEAPON_CONFIGS.DESERT_EAGLE.bulletSize,
                WEAPON_CONFIGS.DESERT_EAGLE.bulletColor,
                WEAPON_CONFIGS.DESERT_EAGLE.texture,
                WEAPON_CONFIGS.DESERT_EAGLE.burstCount,
                WEAPON_CONFIGS.DESERT_EAGLE.burstDelay,
                WEAPON_CONFIGS.DESERT_EAGLE.bulletCost,
                WEAPON_CONFIGS.DESERT_EAGLE.specialEffect,
                WEAPON_CONFIGS.DESERT_EAGLE.isContinuous,
                WEAPON_CONFIGS.DESERT_EAGLE.duration,
                WEAPON_CONFIGS.DESERT_EAGLE.config
            ),
            new Weapon(
                WEAPON_CONFIGS.GATLING.name,
                WEAPON_CONFIGS.GATLING.damage,
                WEAPON_CONFIGS.GATLING.fireRate,
                WEAPON_CONFIGS.GATLING.bulletSpeed,
                WEAPON_CONFIGS.GATLING.bulletSize,
                WEAPON_CONFIGS.GATLING.bulletColor,
                WEAPON_CONFIGS.GATLING.texture,
                WEAPON_CONFIGS.GATLING.burstCount,
                WEAPON_CONFIGS.GATLING.burstDelay,
                WEAPON_CONFIGS.GATLING.bulletCost,
                WEAPON_CONFIGS.GATLING.specialEffect,
                WEAPON_CONFIGS.GATLING.isContinuous,
                WEAPON_CONFIGS.GATLING.duration,
                WEAPON_CONFIGS.GATLING.config
            ),
            new Weapon(
                WEAPON_CONFIGS.SONIC_GUN.name,
                WEAPON_CONFIGS.SONIC_GUN.damage,
                WEAPON_CONFIGS.SONIC_GUN.fireRate,
                WEAPON_CONFIGS.SONIC_GUN.bulletSpeed,
                WEAPON_CONFIGS.SONIC_GUN.bulletSize,
                WEAPON_CONFIGS.SONIC_GUN.bulletColor,
                WEAPON_CONFIGS.SONIC_GUN.texture,
                WEAPON_CONFIGS.SONIC_GUN.burstCount,
                WEAPON_CONFIGS.SONIC_GUN.burstDelay,
                WEAPON_CONFIGS.SONIC_GUN.bulletCost,
                WEAPON_CONFIGS.SONIC_GUN.specialEffect,
                WEAPON_CONFIGS.SONIC_GUN.isContinuous,
                WEAPON_CONFIGS.SONIC_GUN.duration,
                WEAPON_CONFIGS.SONIC_GUN.config
            ),
            new Weapon(
                WEAPON_CONFIGS.MISSILE.name,
                WEAPON_CONFIGS.MISSILE.damage,
                WEAPON_CONFIGS.MISSILE.fireRate,
                WEAPON_CONFIGS.MISSILE.bulletSpeed,
                WEAPON_CONFIGS.MISSILE.bulletSize,
                WEAPON_CONFIGS.MISSILE.bulletColor,
                WEAPON_CONFIGS.MISSILE.texture,
                WEAPON_CONFIGS.MISSILE.burstCount,
                WEAPON_CONFIGS.MISSILE.burstDelay,
                WEAPON_CONFIGS.MISSILE.bulletCost,
                WEAPON_CONFIGS.MISSILE.specialEffect,
                WEAPON_CONFIGS.MISSILE.isContinuous,
                WEAPON_CONFIGS.MISSILE.duration,
                WEAPON_CONFIGS.MISSILE.config
            ),
            new Weapon(
                WEAPON_CONFIGS.NUKE.name,
                WEAPON_CONFIGS.NUKE.damage,
                WEAPON_CONFIGS.NUKE.fireRate,
                WEAPON_CONFIGS.NUKE.bulletSpeed,
                WEAPON_CONFIGS.NUKE.bulletSize,
                WEAPON_CONFIGS.NUKE.bulletColor,
                WEAPON_CONFIGS.NUKE.texture,
                WEAPON_CONFIGS.NUKE.burstCount,
                WEAPON_CONFIGS.NUKE.burstDelay,
                WEAPON_CONFIGS.NUKE.bulletCost,
                WEAPON_CONFIGS.NUKE.specialEffect,
                WEAPON_CONFIGS.NUKE.isContinuous,
                WEAPON_CONFIGS.NUKE.duration,
                WEAPON_CONFIGS.NUKE.config
            )
        ];
        
        this.weaponCooldowns = [0, 0, 0, 0, 0, 0];
        this.currentWeaponIndex = 0;
        this.currentWeapon = this.weapons[0];
    }
    
    switchWeapon(index) {
        if (this.isGameOver) return;
        
        if (index >= 0 && index < this.weapons.length) {
            const targetWeapon = this.weapons[index];
            
            // Ê£ÄÊü•ÊòØÂê¶ÈúÄË¶ÅË¥≠‰π∞Â≠êÂºπ
            if (targetWeapon.bulletCost > 0 && targetWeapon.bulletCount <= 0) {
                const costFor5Bullets = targetWeapon.bulletCost * 5;
                
                if (this.score >= costFor5Bullets) {
                    this.score -= costFor5Bullets;
                    targetWeapon.bulletCount = 5;
                    this.showBulletPurchaseMessage(targetWeapon.name, 5, costFor5Bullets);
                } else {
                    this.showInsufficientScoreForBulletsMessage(targetWeapon.name, costFor5Bullets);
                    return;
                }
            }
            
            this.currentWeaponIndex = index;
            this.currentWeapon = targetWeapon;
            
            if (this.touchControls && this.touchControls.isMobile) {
                this.touchControls.highlightWeaponButton(index);
            }
            
            this.showWeaponSwitchMessage();
        }
    }
    
    showBulletPurchaseMessage(weaponName, bulletCount, cost) {
        if (this.weaponSwitchText) {
            this.weaponSwitchText.destroy();
        }
        
        this.weaponSwitchText = this.add.text(640, 200, `Ëá™Âä®Ë¥≠‰π∞${weaponName}Â≠êÂºπ${bulletCount}ÂèëÔºåÊ∂àËÄó${cost}ÁßØÂàÜ`, {
            font: '24px Arial',
            fill: '#00ff00',
            stroke: '#000000',
            strokeThickness: 3
        }).setOrigin(0.5).setScrollFactor(0); // üÜï Ê®™ÁâàÂç∑ËΩ¥ÔºöÂõ∫ÂÆöÊòæÁ§∫
        
        this.time.delayedCall(2000, () => {
            if (this.weaponSwitchText) {
                this.weaponSwitchText.destroy();
                this.weaponSwitchText = null;
            }
        }, null, this);
    }
    
    showInsufficientScoreForBulletsMessage(weaponName, requiredScore) {
        if (this.weaponSwitchText) {
            this.weaponSwitchText.destroy();
        }
        
        this.weaponSwitchText = this.add.text(640, 200, `ÁßØÂàÜ‰∏çË∂≥Ë¥≠‰π∞${weaponName}Â≠êÂºπÔºÅÈúÄË¶Å${requiredScore}ÁßØÂàÜ`, {
            font: '24px Arial',
            fill: '#ff0000',
            stroke: '#000000',
            strokeThickness: 3
        }).setOrigin(0.5).setScrollFactor(0); // üÜï Ê®™ÁâàÂç∑ËΩ¥ÔºöÂõ∫ÂÆöÊòæÁ§∫
        
        this.time.delayedCall(2000, () => {
            if (this.weaponSwitchText) {
                this.weaponSwitchText.destroy();
                this.weaponSwitchText = null;
            }
        }, null, this);
    }
    

    
    showWeaponSwitchMessage() {
        if (this.weaponSwitchText) {
            this.weaponSwitchText.destroy();
        }
        
        this.weaponSwitchText = this.add.text(640, 200, `Ê≠¶Âô®: ${this.currentWeapon.name}`, {
            font: '24px Arial',
            fill: '#ffffff',
            stroke: '#000000',
            strokeThickness: 3
        }).setOrigin(0.5).setScrollFactor(0); // üÜï Ê®™ÁâàÂç∑ËΩ¥ÔºöÂõ∫ÂÆöÊòæÁ§∫
        
        this.time.delayedCall(2000, () => {
            if (this.weaponSwitchText) {
                this.weaponSwitchText.destroy();
                this.weaponSwitchText = null;
            }
        }, null, this);
    }

    // üÜï ÂàùÂßãÂåñË°ÄÈáèÁ≥ªÁªü
    initHealthSystem() {
        this.maxHealth = this.selectedPlayer ? this.selectedPlayer.health : GAME_CONFIG.MAX_HEALTH;
        this.currentHealth = this.maxHealth;
        this.damagePerEnemyEscape = 10;
        this.collisionDamage = 20;
        this.invincibilityTime = 500;
    }

    createBackground() {
        if (this.textures.exists('background')) {
            console.log('MainScene: ‰ΩøÁî®backgroundÁ∫πÁêÜÂàõÂª∫ËÉåÊôØ');
            // ÂàõÂª∫Âπ≥Èì∫ËÉåÊôØ
            for (let x = 0; x < 1280; x += 64) {
                for (let y = 0; y < 720; y += 64) {
                    this.add.image(x, y, 'background').setOrigin(0, 0);
                }
            }
        } else {
            console.log('MainScene: backgroundÁ∫πÁêÜ‰∏çÂ≠òÂú®Ôºå‰ΩøÁî®ÂÅèÊ∑°ËÉåÊôØ');
            this.add.rectangle(640, 360, 1280, 720, 0xe8f4f8); // ÂÅèÊ∑°ÁöÑËìùÁôΩËâ≤ËÉåÊôØ
        }
    }

    createPlayer() {
        // Á°ÆÂÆö‰ΩøÁî®Âì™‰∏™Á∫πÁêÜ
        let playerTexture = 'player'; // ÈªòËÆ§
      
        // È¢ÑËÆæÁé©ÂÆ∂Â±ûÊÄß
        this.playerSpeed = GAME_CONFIG.PLAYER_SPEED;
        this.playerSize = GAME_CONFIG.PLAYER_SIZE;
      
        if (this.selectedPlayer && this.textures.exists(this.selectedPlayer.key)) {
            playerTexture = this.selectedPlayer.key;
            this.playerSpeed = this.selectedPlayer.speed || 400;
            console.log('MainScene: ‰ΩøÁî®ËßíËâ≤Á∫πÁêÜ:', playerTexture, 'ÈÄüÂ∫¶:', this.playerSpeed);
        } else {
            console.log('MainScene: ‰ΩøÁî®ÈªòËÆ§Áé©ÂÆ∂Á∫πÁêÜ:', playerTexture);
        }
          
        this.player = this.physics.add.sprite(100, 360, playerTexture)
            .setCollideWorldBounds(true)
            .setDisplaySize(this.playerSize, this.playerSize);
    
        // ËÆæÁΩÆÁé©ÂÆ∂Â±ûÊÄßÂà∞ sprite
        this.player.playerSpeed = this.playerSpeed;
        this.player.isInvincible = false;
    
        console.log('MainScene: Áé©ÂÆ∂ÂàõÂª∫ÂÆåÊàêÔºåÈÄüÂ∫¶:', this.playerSpeed);
    }

    // üÜï ÂàõÂª∫Á≤íÂ≠êÊïàÊûúÁ≥ªÁªü
    createParticleSystems() {
        // Â∞ÑÂáªÁ≤íÂ≠êÊïàÊûú
        this.shootEmitter = this.add.particles(0, 0, 'shoot', {
            speed: { min: 50, max: 150 },
            scale: { start: 0.5, end: 0 },
            alpha: { start: 1, end: 0 },
            lifespan: 300,
            frequency: 50,
            blendMode: 'ADD'
        });
        
        // ÁàÜÁÇ∏Á≤íÂ≠êÊïàÊûú
        this.explosionEmitter = this.add.particles(0, 0, 'explosion', {
            speed: { min: 100, max: 300 },
            scale: { start: 1, end: 0 },
            alpha: { start: 1, end: 0 },
            lifespan: 500,
            frequency: 20,
            blendMode: 'ADD',
            angle: { min: 0, max: 360 }
        });
        
        // Âèó‰º§Á≤íÂ≠êÊïàÊûú
        this.damageEmitter = this.add.particles(0, 0, 'damage', {
            speed: { min: 30, max: 80 },
            scale: { start: 0.3, end: 0 },
            alpha: { start: 1, end: 0 },
            lifespan: 400,
            frequency: 30,
            blendMode: 'ADD',
            angle: { min: -30, max: 30 }
        });
        
        // Êïå‰∫∫Ê≠ª‰∫°Á≤íÂ≠êÊïàÊûú
        this.deathEmitter = this.add.particles(0, 0, 'death', {
            speed: { min: 80, max: 200 },
            scale: { start: 0.8, end: 0 },
            alpha: { start: 1, end: 0 },
            lifespan: 600,
            frequency: 25,
            blendMode: 'ADD',
            angle: { min: 0, max: 360 }
        });
        
        console.log('MainScene: Á≤íÂ≠êÊïàÊûúÁ≥ªÁªüÂàõÂª∫ÂÆåÊàê');
    }

    // üÜï ÂàõÂª∫Ë°ÄÈáèÊù°
    createHealthBar() {
        const barWidth = 200;
        const barHeight = 20;
        const barX = 20;
        const barY = 85;
      
        // Ë°ÄÈáèÊù°ËÉåÊôØ
        this.healthBarBg = this.add.graphics();
        this.healthBarBg.fillStyle(0x333333);
        this.healthBarBg.fillRect(barX, barY, barWidth, barHeight);
        this.healthBarBg.lineStyle(2, 0xffffff);
        this.healthBarBg.strokeRect(barX, barY, barWidth, barHeight);
        this.healthBarBg.setScrollFactor(0); // üÜï Ê®™ÁâàÂç∑ËΩ¥ÔºöÂõ∫ÂÆöÊòæÁ§∫
      
        // Ë°ÄÈáèÊù°ÂâçÊôØ
        this.healthBar = this.add.graphics();
        this.healthBar.setScrollFactor(0); // üÜï Ê®™ÁâàÂç∑ËΩ¥ÔºöÂõ∫ÂÆöÊòæÁ§∫
        this.updateHealthBar();
    }
    
    // üÜï Ê®™ÁâàÂç∑ËΩ¥ÔºöÂàõÂª∫Ë∑ùÁ¶ªËøõÂ∫¶Êù°
    createDistanceProgressBar() {
        const barWidth = 400;
        const barHeight = 8;
        const barX = 640 - barWidth / 2;
        const barY = 80;
      
        // Ë∑ùÁ¶ªËøõÂ∫¶Êù°ËÉåÊôØ
        this.distanceBarBg = this.add.graphics();
        this.distanceBarBg.fillStyle(0x333333);
        this.distanceBarBg.fillRect(barX, barY, barWidth, barHeight);
        this.distanceBarBg.lineStyle(1, 0x00ffff);
        this.distanceBarBg.strokeRect(barX, barY, barWidth, barHeight);
        this.distanceBarBg.setScrollFactor(0); // üÜï Ê®™ÁâàÂç∑ËΩ¥ÔºöÂõ∫ÂÆöÊòæÁ§∫
      
        // Ë∑ùÁ¶ªËøõÂ∫¶Êù°ÂâçÊôØ
        this.distanceBar = this.add.graphics();
        this.distanceBar.setScrollFactor(0); // üÜï Ê®™ÁâàÂç∑ËΩ¥ÔºöÂõ∫ÂÆöÊòæÁ§∫
        this.updateDistanceProgressBar();
    }
    
    // üÜï Ê®™ÁâàÂç∑ËΩ¥ÔºöÂàõÂª∫Â∞èÂú∞Âõæ
    createMiniMap() {
        const mapSize = 120;
        const mapX = 1280 - mapSize - 20;
        const mapY = 180;
        
        // Â∞èÂú∞ÂõæËÉåÊôØ
        this.miniMapBg = this.add.graphics();
        this.miniMapBg.fillStyle(0x000000, 0.7);
        this.miniMapBg.fillRect(mapX, mapY, mapSize, mapSize);
        this.miniMapBg.lineStyle(2, 0x00ffff);
        this.miniMapBg.strokeRect(mapX, mapY, mapSize, mapSize);
        this.miniMapBg.setScrollFactor(0);
        
        // Â∞èÂú∞ÂõæÂÜÖÂÆπ
        this.miniMap = this.add.graphics();
        this.miniMap.setScrollFactor(0);
        
        // Â∞èÂú∞ÂõæÊ†áÈ¢ò
        this.miniMapTitle = this.add.text(mapX + mapSize/2, mapY - 10, 'Â∞èÂú∞Âõæ', {
            font: '12px Arial',
            fill: '#00ffff',
            backgroundColor: '#000000',
            padding: { x: 4, y: 2 }
        }).setOrigin(0.5, 1).setScrollFactor(0);
        
        this.updateMiniMap();
    }

    // üÜï Êõ¥Êñ∞Ë°ÄÈáèÊù°
    updateHealthBar() {
        if (!this.healthBar) return;
      
        const barWidth = 200;
        const barHeight = 20;
        const barX = 20;
        const barY = 85;
      
        this.healthBar.clear();
      
        // ËÆ°ÁÆóË°ÄÈáèÁôæÂàÜÊØî
        const healthPercent = this.currentHealth / this.maxHealth;
        const currentBarWidth = barWidth * healthPercent;
      
        // Ê†πÊçÆË°ÄÈáèÁôæÂàÜÊØîÈÄâÊã©È¢úËâ≤
        let barColor;
        if (healthPercent > 0.6) {
            barColor = 0x00ff00; // ÁªøËâ≤
        } else if (healthPercent > 0.3) {
            barColor = 0xffff00; // ÈªÑËâ≤
        } else {
            barColor = 0xff0000; // Á∫¢Ëâ≤
        }
      
        this.healthBar.fillStyle(barColor);
        this.healthBar.fillRect(barX, barY, currentBarWidth, barHeight);
    }
    
    // üÜï Ê®™ÁâàÂç∑ËΩ¥ÔºöÊõ¥Êñ∞Ë∑ùÁ¶ªËøõÂ∫¶Êù°
    updateDistanceProgressBar() {
        if (!this.distanceBar || !this.player) return;
      
        const barWidth = 400;
        const barHeight = 8;
        const barX = 640 - barWidth / 2;
        const barY = 80;
      
        this.distanceBar.clear();
      
        // ËÆ°ÁÆóË∑ùÁ¶ªËøõÂ∫¶ÔºàÂü∫‰∫éÁé©ÂÆ∂X‰ΩçÁΩÆÔºâ
        const currentDistance = Math.max(0, this.player.x);
        const maxDistance = 4000; // ÂÖ≥Âç°ÊÄªÈïøÂ∫¶
        const progress = Math.min(1, currentDistance / maxDistance);
        const currentBarWidth = barWidth * progress;
      
        // ËÆæÁΩÆËøõÂ∫¶Êù°È¢úËâ≤Ôºà‰ªéÁªøËâ≤Ê∏êÂèòÂà∞Á∫¢Ëâ≤Ôºâ
        let barColor;
        if (progress < 0.5) {
            barColor = 0x00ff00; // ÁªøËâ≤
        } else if (progress < 0.8) {
            barColor = 0xffff00; // ÈªÑËâ≤
        } else {
            barColor = 0xff0000; // Á∫¢Ëâ≤ÔºàÊé•ËøëBOSSÔºâ
        }
      
        this.distanceBar.fillStyle(barColor);
        this.distanceBar.fillRect(barX, barY, currentBarWidth, barHeight);
      
        // Êõ¥Êñ∞Ë∑ùÁ¶ªÊñáÊú¨
        if (this.distanceText) {
            this.distanceText.setText(`Ë∑ùÁ¶ª: ${Math.round(currentDistance)}/${maxDistance}`);
        }
    }
    
    // üÜï Ê®™ÁâàÂç∑ËΩ¥ÔºöÊõ¥Êñ∞Â∞èÂú∞Âõæ
    updateMiniMap() {
        if (!this.miniMap || !this.player) return;
        
        const mapSize = 120;
        const mapX = 1280 - mapSize - 20;
        const mapY = 180;
        const worldWidth = 4000;
        const worldHeight = 720;
        
        this.miniMap.clear();
        
        // ÁªòÂà∂‰∏ñÁïåËæπÁïå
        this.miniMap.lineStyle(1, 0x444444);
        this.miniMap.strokeRect(mapX + 2, mapY + 2, mapSize - 4, mapSize - 4);
        
        // ÁªòÂà∂Áé©ÂÆ∂‰ΩçÁΩÆ
        const playerMapX = mapX + (this.player.x / worldWidth) * (mapSize - 4) + 2;
        const playerMapY = mapY + (this.player.y / worldHeight) * (mapSize - 4) + 2;
        this.miniMap.fillStyle(0x00ff00);
        this.miniMap.fillCircle(playerMapX, playerMapY, 3);
        
        // ÁªòÂà∂Êïå‰∫∫‰ΩçÁΩÆ
        if (this.enemies) {
            this.miniMap.fillStyle(0xff0000);
            this.enemies.children.entries.forEach(enemy => {
                if (enemy.active) {
                    const enemyMapX = mapX + (enemy.x / worldWidth) * (mapSize - 4) + 2;
                    const enemyMapY = mapY + (enemy.y / worldHeight) * (mapSize - 4) + 2;
                    this.miniMap.fillCircle(enemyMapX, enemyMapY, 1);
                }
            });
        }
        
        // ÁªòÂà∂ÊëÑÂÉèÊú∫ËßÜÁ™ó
        const cameraLeft = this.cameras.main.scrollX;
        const cameraRight = cameraLeft + 1280;
        const cameraMapLeft = mapX + (cameraLeft / worldWidth) * (mapSize - 4) + 2;
        const cameraMapRight = mapX + (cameraRight / worldWidth) * (mapSize - 4) + 2;
        this.miniMap.lineStyle(1, 0x00ffff, 0.5);
        this.miniMap.strokeRect(cameraMapLeft, mapY + 2, cameraMapRight - cameraMapLeft, mapSize - 4);
    }

    // üÜï ‰øÆÊîπÊïå‰∫∫ÁîüÊàêÊñπÊ≥ïÔºàÊ®™ÁâàÂç∑ËΩ¥ÁâàÊú¨Ôºâ
    spawnEnemy() {
        if (this.isGameOver) return;
        
        console.log('MainScene: Ê®™ÁâàÂç∑ËΩ¥Êïå‰∫∫ÁîüÊàê');
        
        if (!this.textures.exists('enemy')) {
            console.error('MainScene: Êïå‰∫∫Á∫πÁêÜ‰∏çÂ≠òÂú®ÔºÅ');
            return;
        }
        
        const y = Phaser.Math.Between(50, 670);
        // üÜï Ê®™ÁâàÂç∑ËΩ¥ÔºöÂú®ÊëÑÂÉèÊú∫Âè≥‰æßÂ§ñÁîüÊàêÊïå‰∫∫
        const spawnX = this.cameras.main.scrollX + 900; // ÊëÑÂÉèÊú∫Âè≥‰æß900ÂÉèÁ¥†Â§Ñ
        const enemy = this.enemies.create(spawnX, y, 'enemy');
        
        if (enemy) {
            enemy.setDisplaySize(32, 32);
            enemy.setVelocityX(-100); // ÂêëÂ∑¶ÁßªÂä®ÔºàÁõ∏ÂØπ‰∏ñÁïåÂùêÊ†áÔºâ
            
            if (enemy.body) {
                enemy.body.enable = true;
            }
            
            enemy.checkBounds = true;
            
            console.log(`MainScene: Ê®™ÁâàÂç∑ËΩ¥Êïå‰∫∫ÁîüÊàêÊàêÂäüÔºå‰ΩçÁΩÆ: (${enemy.x}, ${enemy.y})ÔºåÂΩìÂâçÊïå‰∫∫Êï∞Èáè: ${this.enemies.children.size}`);
        } else {
            console.error('MainScene: Êó†Ê≥ïÂàõÂª∫Êïå‰∫∫ÂØπË±°');
        }
    }

    // üÜï ‰øÆÊîπÊïå‰∫∫ÈÄÉËÑ±Ê£ÄÊü•ÔºàÊ®™ÁâàÂç∑ËΩ¥ÁâàÊú¨Ôºâ
    checkEnemyEscape() {
        if (this.isGameOver) return;
      
        const cameraLeft = this.cameras.main.scrollX;
        
        this.enemies.children.entries.forEach(enemy => {
            if (enemy.active && enemy.x < cameraLeft - 100) { // Êïå‰∫∫ÁßªÂá∫ÊëÑÂÉèÊú∫Â∑¶‰æß
                console.log('MainScene: Ê®™ÁâàÂç∑ËΩ¥Êïå‰∫∫ÈÄÉËÑ±ÔºÅ');
                this.handleEnemyEscape(enemy);
            }
        });
    }

    // üÜï Â§ÑÁêÜÊïå‰∫∫ÈÄÉËÑ±
    handleEnemyEscape(enemy) {
        // Êâ£Èô§Ë°ÄÈáè
        this.currentHealth -= this.damagePerEnemyEscape;
      
        // Á°Æ‰øùË°ÄÈáè‰∏ç‰Ωé‰∫é0
        if (this.currentHealth < 0) {
            this.currentHealth = 0;
        }
      
        console.log(`MainScene: Êïå‰∫∫ÈÄÉËÑ±Êâ£Ë°Ä ${this.damagePerEnemyEscape}ÔºåÂΩìÂâçË°ÄÈáè: ${this.currentHealth}/${this.maxHealth}`);
      
        // ÈîÄÊØÅÊïå‰∫∫
        enemy.destroy();
      
        // üÜï ËßÜËßâÂèçÈ¶àÊïàÊûú
        this.showDamageEffect(this.damagePerEnemyEscape, 'escape');
      
        // Êõ¥Êñ∞HUD
        this.updateHUD();
      
        // Ê£ÄÊü•Ê∏∏ÊàèÊòØÂê¶ÁªìÊùü
        if (this.currentHealth <= 0) {
            this.gameOver();
        }
    }

    // üÜï ÊòæÁ§∫Âèó‰º§ÊïàÊûú
    showDamageEffect(damageAmount, damageType = 'escape') {
        // üÜï Âèó‰º§Á≤íÂ≠êÊïàÊûú
        this.damageEmitter.setPosition(this.player.x, this.player.y);
        this.damageEmitter.start();
        this.time.delayedCall(150, () => {
            this.damageEmitter.stop();
        });
        
        // Â±èÂπïÁ∫¢Ëâ≤Èó™ÁÉÅÊïàÊûú
        const damageOverlay = this.add.rectangle(640, 360, 1280, 720, 0xff0000, 0.3).setScrollFactor(0); // üÜï Ê®™ÁâàÂç∑ËΩ¥ÔºöÂõ∫ÂÆöÊòæÁ§∫
      
        // Èó™ÁÉÅÂä®Áîª
        this.tweens.add({
            targets: damageOverlay,
            alpha: 0,
            duration: 200,
            onComplete: () => {
                damageOverlay.destroy();
            }
        });
      
        // ÊëÑÂÉèÊú∫ÈúáÂä®ÊïàÊûú
        this.cameras.main.shake(100, 0.02);
      
        // Ê†πÊçÆ‰º§ÂÆ≥Á±ªÂûãÊòæÁ§∫‰∏çÂêåÊñáÂ≠óÂíåÈ¢úËâ≤
        let damageText, textColor;
        if (damageType === 'escape') {
            damageText = `-${damageAmount} HP (Êïå‰∫∫ÈÄÉËÑ±)`;
            textColor = '#ff6600';
        } else {
            damageText = `-${damageAmount} HP (Áõ¥Êé•ÊíûÂáª)`;
            textColor = '#ff0000';
        }
      
        const damage = this.add.text(640, 300, damageText, {
            font: '24px Arial',
            fill: textColor,
            stroke: '#ffffff',
            strokeThickness: 2
        }).setOrigin(0.5).setScrollFactor(0); // üÜï Ê®™ÁâàÂç∑ËΩ¥ÔºöÂõ∫ÂÆöÊòæÁ§∫
      
        // ‰º§ÂÆ≥ÊñáÂ≠óÂä®Áîª
        this.tweens.add({
            targets: damage,
            y: damage.y - 50,
            alpha: 0,
            duration: 1000,
            onComplete: () => {
                damage.destroy();
            }
        });
    }

    // Êõ¥Êñ∞HUDÊòæÁ§∫
    updateHUD() {
        if (this.scoreText) {
            this.scoreText.setText(`ÂàÜÊï∞: ${this.score}`);
        }
        if (this.healthText) {
            this.healthText.setText(`Ë°ÄÈáè: ${this.currentHealth}/${this.maxHealth}`);
        }
        if (this.levelText) {
            this.levelText.setText(`ÂÖ≥Âç°: ${this.level}`);
        }
        if (this.weaponText) {
            this.weaponText.setText(`Ê≠¶Âô®: ${this.currentWeapon.name}`);
        }
        if (this.bulletCountText) {
            // üÜï Êõ¥Êñ∞Â≠êÂºπÊï∞ÈáèÊòæÁ§∫
            let bulletText;
            if (this.currentWeapon.bulletCost === 0) {
                bulletText = 'Â≠êÂºπ: Êó†Èôê';
                this.bulletCountText.setFill('#00ff00');
            } else {
                bulletText = `Â≠êÂºπ: ${this.currentWeapon.bulletCount}Âèë`;
                // üÜï Ê†πÊçÆÂ≠êÂºπÊï∞ÈáèÊîπÂèòÈ¢úËâ≤
                if (this.currentWeapon.bulletCount <= 0) {
                    this.bulletCountText.setFill('#ff0000'); // Á∫¢Ëâ≤Ë°®Á§∫Êó†Â≠êÂºπ
                } else if (this.currentWeapon.bulletCount <= 2) {
                    this.bulletCountText.setFill('#ffff00'); // ÈªÑËâ≤Ë°®Á§∫Â≠êÂºπÂ∞ë
                } else {
                    this.bulletCountText.setFill('#00ff00'); // ÁªøËâ≤Ë°®Á§∫Â≠êÂºπÂÖÖË∂≥
                }
            }
            this.bulletCountText.setText(bulletText);
        }
        if (this.killText) {
            this.killText.setText(`ÂáªÊùÄ: ${this.killCount}/${this.levelCompleteKills}`);
        }
      
        // üÜï Êõ¥Êñ∞Ë∑ùÁ¶ªÊòæÁ§∫
        if (this.distanceText && this.player) {
            const currentDistance = Math.max(0, Math.round(this.player.x));
            this.distanceText.setText(`Ë∑ùÁ¶ª: ${currentDistance}/4000`);
        }
        
        // üÜï Ê®™ÁâàÂç∑ËΩ¥ÔºöÊõ¥Êñ∞Ë∑ùÁ¶ªËøõÂ∫¶Êù°
        this.updateDistanceProgressBar();
        
        // üÜï Ê®™ÁâàÂç∑ËΩ¥ÔºöÊõ¥Êñ∞Â∞èÂú∞Âõæ
        this.updateMiniMap();
        
        // üÜï Êõ¥Êñ∞Êó∂Èó¥ÊòæÁ§∫
        if (this.timeText) {
            // ÂÖ≥Âç°ÁªìÊùüÂêéÂÅúÊ≠¢ËÆ°Êó∂
            const elapsedTime = this.isGameOver || this.levelComplete ? 
                Math.floor((this.levelEndTime - this.gameStartTime) / 1000) : 
                Math.floor((this.time.now - this.gameStartTime) / 1000);
            const minutes = Math.floor(elapsedTime / 60);
            const seconds = elapsedTime % 60;
            const timeString = `Êó∂Èó¥: ${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            this.timeText.setText(timeString);
        }
      
        // Êõ¥Êñ∞Ë°ÄÈáèÊù°
        this.updateHealthBar();
        if (this.powerUpManager) {
            this.updatePowerUpHUD();
        }
        // üÜï ÊòæÁ§∫ÈöúÁ¢çÁâ©Áä∂ÊÄÅ
        if (this.obstacleManager) {
            const obstacleStatus = this.obstacleManager.getObstacleStatus();
            if (this.obstacleText) {
                this.obstacleText.setText(`ü™® ÈöúÁ¢çÁâ©: ${obstacleStatus.count}/${obstacleStatus.maxCount}`);
            }
        }
        
        // üåç ÊòæÁ§∫ÂΩìÂâçÂú∫ÊôØ‰ø°ÊÅØ
        if (this.advancedSceneManager) {
            const sceneStatus = this.advancedSceneManager.getSceneStatus();
            if (this.sceneText) {
                this.sceneText.setText(`üåç Âú∫ÊôØ: ${sceneStatus.currentScene}`);
            }
        }
        
        // üåç ÊòæÁ§∫Âú∫ÊôØÂàáÊç¢ÊèêÁ§∫
        if (this.sceneHintText) {
            this.sceneHintText.setText(`Êåâ M ÈîÆÂàáÊç¢Âú∫ÊôØ`);
        }
    }

    // üîÑ ÈáçÊûÑÂêéÁöÑupdateÊñπÊ≥ï - Ê®°ÂùóÂåñËÆæËÆ°
    update() {
        // Âü∫Á°ÄÊ£ÄÊü•
        if (!this.isGameActive()) return;
        
        // Êõ¥Êñ∞ÂêÑ‰∏™Á≥ªÁªü
        this.updatePlayerSystem();
        this.updateEnemySystem();
        this.updateWeaponSystem();
        this.updatePowerUpSystem();
        this.updateObstacleSystem();
        this.updateSceneSystem();
        this.updateUISystem();
        
        // Ê£ÄÊü•Ê∏∏ÊàèÁä∂ÊÄÅ
        this.checkGameState();
    }

    // ‚úÖ Ê£ÄÊü•Ê∏∏ÊàèÊòØÂê¶Ê¥ªË∑É
    isGameActive() {
        return this.player && this.player.active && !this.scene.isPaused();
    }

    // üéÆ Êõ¥Êñ∞Áé©ÂÆ∂Á≥ªÁªü
    updatePlayerSystem() {
        if (this.isGameOver) return;
        
        // Êõ¥Êñ∞Ëß¶Êë∏ÊéßÂà∂
        if (this.touchControls) {
            this.touchControls.update();
        }
        
        // ÈîÆÁõòÊéßÂà∂ÔºàÈùûËß¶Êë∏ËÆæÂ§áÔºâ
        if (!this.touchControls || !this.touchControls.isMobile) {
            this.updatePlayerMovement();
        }
    }

    // üéÆ Êõ¥Êñ∞Áé©ÂÆ∂ÁßªÂä®
    updatePlayerMovement() {
            this.player.setVelocity(0);
          
        // Ê∞¥Âπ≥ÁßªÂä®
            if (this.cursors.left.isDown || this.wasdKeys.A.isDown) {
                    this.player.setVelocityX(-this.playerSpeed);
            } else if (this.cursors.right.isDown || this.wasdKeys.D.isDown) {
                this.player.setVelocityX(this.playerSpeed);
            }
          
        // ÂûÇÁõ¥ÁßªÂä®ÔºàÈôêÂà∂Âú®‰∏ñÁïåËæπÁïåÂÜÖÔºâ
            if (this.cursors.up.isDown || this.wasdKeys.W.isDown) {
            if (this.player.y > 50) {
                this.player.setVelocityY(-this.playerSpeed);
            }
            } else if (this.cursors.down.isDown || this.wasdKeys.S.isDown) {
            if (this.player.y < 670) {
                this.player.setVelocityY(this.playerSpeed);
            }
        }
    }

    // üëæ Êõ¥Êñ∞Êïå‰∫∫Á≥ªÁªü
    updateEnemySystem() {
        // Êõ¥Êñ∞ÊâÄÊúâÊïå‰∫∫AI
        this.enemies.children.entries.forEach(enemy => {
            if (enemy.active && enemy.update) {
                enemy.update();
            }
        });
        
        // Ê£ÄÊü•Êïå‰∫∫ÈÄÉËÑ±
        this.checkEnemyEscape();
    }

    // üî´ Êõ¥Êñ∞Ê≠¶Âô®Á≥ªÁªü
    updateWeaponSystem() {
        // Ê≠¶Âô®Á≥ªÁªüÊõ¥Êñ∞ÈÄªËæëÔºàÂ¶ÇÊûúÈúÄË¶ÅÔºâ
        if (this.currentWeapon && this.currentWeapon.update) {
            this.currentWeapon.update();
        }
    }

    // ‚ö° Êõ¥Êñ∞ÈÅìÂÖ∑Á≥ªÁªü
    updatePowerUpSystem() {
        if (this.powerUpManager) {
            this.powerUpManager.update();
        }
    }

    // ü™® Êõ¥Êñ∞ÈöúÁ¢çÁâ©Á≥ªÁªü
    updateObstacleSystem() {
        if (this.obstacleManager) {
            this.obstacleManager.update(this.time.now, this.game.loop.delta);
        }
        }
        
    // üåç Êõ¥Êñ∞Âú∫ÊôØÁ≥ªÁªü
    updateSceneSystem() {
        if (this.advancedSceneManager) {
            this.advancedSceneManager.update(this.time.now, this.game.loop.delta);
        }
        
        // Ê£ÄÊü•Âú∫ÊôØÂàáÊç¢Âø´Êç∑ÈîÆ
        if (Phaser.Input.Keyboard.JustDown(this.sceneKey)) {
            this.sceneSwitcher.toggle();
        }
    }

    // üìä Êõ¥Êñ∞UIÁ≥ªÁªü
    updateUISystem() {
        if (this.uiManager) {
            this.uiManager.updateHUD();
        } else {
            // ÂÖºÂÆπÊóßÁâàÊú¨
            this.updateHUD();
        }
    }

    // üéØ Ê£ÄÊü•Ê∏∏ÊàèÁä∂ÊÄÅ
    checkGameState() {
        if (this.isGameOver) {
            this.updateUISystem();
            return;
        }
        
        // Ê£ÄÊü•ÂÖ≥Âç°ÂÆåÊàêÊù°‰ª∂
        this.checkLevelComplete();
    }

    // üÜï ‰øÆÊîπÁé©ÂÆ∂Âèó‰º§ÈÄªËæë
    handlePlayerHit(player, enemy) {
        if (player.isInvincible) return; // Èò≤Ê≠¢Êó†ÊïåÊó∂Èó¥ÂÜÖÈáçÂ§çÂèó‰º§
      
        enemy.destroy();
      
        // Áõ¥Êé•Á¢∞ÊíûÈÄ†ÊàêÊõ¥Â§ß‰º§ÂÆ≥
        const collisionDamage = this.collisionDamage;
        this.currentHealth -= collisionDamage;
      
        if (this.currentHealth < 0) {
            this.currentHealth = 0;
        }
      
        console.log(`MainScene: Áé©ÂÆ∂Ë¢´ÊíûÂáªÊâ£Ë°Ä ${collisionDamage}ÔºåÂΩìÂâçË°ÄÈáè: ${this.currentHealth}/${this.maxHealth}`);
      
        // üîä Êí≠ÊîæÂèó‰º§Èü≥Êïà
        if (this.audioManager) {
            this.audioManager.play('hurt');
        }
      
        // ÊòæÁ§∫Âèó‰º§ÊïàÊûú
        this.showDamageEffect(this.collisionDamage, 'collision');
        this.updateHUD();
      
        // ËÆæÁΩÆÊó†ÊïåÁä∂ÊÄÅ
        player.isInvincible = true;
        player.setTint(0xff0000);
        this.time.delayedCall(this.invincibilityTime, () => {
            if (player && player.active) {
                player.isInvincible = false;
                player.clearTint();
            }
        });
      
        if (this.currentHealth <= 0) {
            this.gameOver();
        }
    }

    handleBulletHit(bullet, enemy) {
        if (!enemy.active) return; // ÁÆÄÂåñÊù°‰ª∂ÔºåÁßªÈô§ isDying Ê£ÄÊü•

        console.log(`MainScene: Â≠êÂºπÂáª‰∏≠Êïå‰∫∫ - Ê≠¶Âô®Á±ªÂûã: ${bullet.weaponType}, Êïå‰∫∫: ${enemy.enemyData ? enemy.enemyData.name : 'Unknown'}`);

        // üîä Êí≠ÊîæÂáª‰∏≠Èü≥Êïà
        if (this.audioManager) {
            this.audioManager.play('hit');
        }

        // üîß ÁâπÊÆäÊ≠¶Âô®Â§ÑÁêÜÔºàÂØºÂºπ„ÄÅÊ†∏ÂºπÔºâ
        if (bullet.weaponType === 'ÂØºÂºπ') {
            console.log('MainScene: ÊâßË°åÂØºÂºπÁàÜÁÇ∏');
            this.executeMissileExplosion(bullet, enemy);
            bullet.destroy();
            return;
        } else if (bullet.weaponType === 'Ê†∏Âºπ') {
            console.log('MainScene: ÊâßË°åÊ†∏ÂºπÁàÜÁÇ∏');
            this.executeNuclearStrike(bullet, enemy);
            bullet.destroy();
            return;
        }

        // üîß ÊôÆÈÄöÊ≠¶Âô® - Â§ÑÁêÜÊïå‰∫∫‰º§ÂÆ≥
        if (enemy.takeDamage) {
            const isDead = enemy.takeDamage(bullet.damage);
            if (isDead) {
                // Êïå‰∫∫Ê≠ª‰∫°ÔºåÂ¢ûÂä†ÂáªÊùÄÊï∞ÂíåÂàÜÊï∞
                this.killCount++;
                let baseScore = bullet.damage;
                // üÜï È™ëÂ£´‰º§ÂÆ≥Âä†Êàê
                if (this.selectedPlayer && this.selectedPlayer.damageMultiplier) {
                    baseScore = Math.round(baseScore * this.selectedPlayer.damageMultiplier);
                }
                const killBonus = 20; // ÂáªÊùÄÂ•ñÂä±
                const scoreGain = baseScore + killBonus;
                this.score += scoreGain;
                
                console.log(`MainScene: ‰ΩøÁî®${bullet.weaponType}ÂáªÊØÅÊïå‰∫∫Ôºå‰º§ÂÆ≥: ${bullet.damage}ÔºåÂæóÂàÜ +${scoreGain}ÔºåÂáªÊùÄÊï∞: ${this.killCount}/${this.levelCompleteKills}ÔºåÂΩìÂâçÂàÜÊï∞: ${this.score}`);
            }
        } else {
            // ÂÖºÂÆπÊóßÁâàÊïå‰∫∫
            enemy.destroy();
            this.killCount++;
            let baseScore = bullet.damage;
            // üÜï È™ëÂ£´‰º§ÂÆ≥Âä†Êàê
            if (this.selectedPlayer && this.selectedPlayer.damageMultiplier) {
                baseScore = Math.round(baseScore * this.selectedPlayer.damageMultiplier);
            }
            const killBonus = 20; // ÂáªÊùÄÂ•ñÂä±
            const scoreGain = baseScore + killBonus;
            this.score += scoreGain;
          
            if (this.deathEmitter) {
                this.deathEmitter.setPosition(enemy.x, enemy.y);
                this.deathEmitter.start();
                this.time.delayedCall(100, () => { if (this.deathEmitter) this.deathEmitter.stop(); });
            }
            
            console.log(`MainScene: ‰ΩøÁî®${bullet.weaponType}ÂáªÊØÅÊïå‰∫∫Ôºå‰º§ÂÆ≥: ${bullet.damage}ÔºåÂæóÂàÜ +${scoreGain}ÔºåÂáªÊùÄÊï∞: ${this.killCount}/${this.levelCompleteKills}ÔºåÂΩìÂâçÂàÜÊï∞: ${this.score}`);
        }
      
        // ÈîÄÊØÅÂ≠êÂºπ
        bullet.destroy();
        this.updateHUD();

        console.log(`MainScene: ‰ΩøÁî®${bullet.weaponType}ÊîªÂáªÂÆåÊàê`);
        
        // üÜï Ê£ÄÊü•ÊòØÂê¶ËææÂà∞ÂáªÊùÄÁõÆÊ†á
        this.checkLevelComplete();
        // ÊôÆÈÄöÊ≠¶Âô®ÂáªÊùÄÊó∂Â∞ùËØïÊéâËêΩÈÅìÂÖ∑
        if (bullet.weaponType !== 'ÂØºÂºπ' && bullet.weaponType !== 'Ê†∏Âºπ') {
            enemy.destroy();
            const enemyType = enemy.enemyData ? enemy.enemyData.name : 'Â∞èÂÖµ';
            if (this.powerUpManager) this.powerUpManager.spawnPowerUp(enemy.x, enemy.y, enemyType);
            // ... ÂÖ∂‰ªñÂáªÊùÄÈÄªËæë ...
        }
    }

    gameOver() {
        if (this.isGameOver) return; // Èò≤Ê≠¢ÈáçÂ§çË∞ÉÁî®
      
        console.log('MainScene: Ê∏∏ÊàèÁªìÊùü - Ë°ÄÈáèËÄóÂ∞Ω');
        this.isGameOver = true;
        
        // üìä ËÆ∞ÂΩïÊ∏∏ÊàèÁªìÊùüÁªüËÆ°
        if (window.StatsManager) {
            const survivalTime = this.time.now - this.gameStartTime;
            window.StatsManager.gameEnd(this.score, survivalTime);
        }
        
        // üîä Êí≠ÊîæÊ∏∏ÊàèÁªìÊùüÈü≥Êïà
        if (this.audioManager) {
            this.audioManager.play('gameOver');
        }
        
        // üÜï ËÆ∞ÂΩïÊ∏∏ÊàèÁªìÊùüÊó∂Èó¥
        this.levelEndTime = this.time.now;
      
        // ÂÅúÊ≠¢Êïå‰∫∫ÁîüÊàê
        if (this.enemySpawner) {
            this.enemySpawner.remove();
            this.enemySpawner = null;
        }
      
        // Ê∏ÖÈô§ÊâÄÊúâÊïå‰∫∫ÂíåÂ≠êÂºπ
        this.enemies.clear(true, true);
        this.bullets.clear(true, true);
        this.enemyBullets.clear(true, true);
      
        // ÊòæÁ§∫Ê∏∏ÊàèÁªìÊùüÁïåÈù¢
        const gameOverBg = this.add.rectangle(640, 360, 400, 200, 0x000000, 0.8).setScrollFactor(0); // üÜï Ê®™ÁâàÂç∑ËΩ¥ÔºöÂõ∫ÂÆöÊòæÁ§∫
      
        this.add.text(640, 320, 'GAME OVER', {
            font: '48px Arial',
            fill: '#ff0000',
            stroke: '#ffffff',
            strokeThickness: 2
        }).setOrigin(0.5).setScrollFactor(0); // üÜï Ê®™ÁâàÂç∑ËΩ¥ÔºöÂõ∫ÂÆöÊòæÁ§∫
      
        this.add.text(640, 380, `ÊúÄÁªàÂàÜÊï∞: ${this.score}`, {
            font: '24px Arial',
            fill: '#ffffff'
        }).setOrigin(0.5).setScrollFactor(0); // üÜï Ê®™ÁâàÂç∑ËΩ¥ÔºöÂõ∫ÂÆöÊòæÁ§∫
      
        this.add.text(640, 410, 'Êåâ R ÈáçÊñ∞ÂºÄÂßã', {
            font: '16px Arial',
            fill: '#cccccc'
        }).setOrigin(0.5).setScrollFactor(0); // üÜï Ê®™ÁâàÂç∑ËΩ¥ÔºöÂõ∫ÂÆöÊòæÁ§∫
      
        // üÜï ÊöÇÂÅúÊ∏∏ÊàèÈÄªËæë‰ΩÜ‰øùÊåÅËæìÂÖ•ÁõëÂê¨Âô®Ê¥ªË∑É
        this.scene.pause();
    }

    startEnemySpawner() {
        console.log('MainScene: ÂêØÂä®Êïå‰∫∫ÁîüÊàêÂô®');
        // ÂÆöÊúüÁîüÊàêÊïå‰∫∫
        this.enemySpawner = this.time.addEvent({
            delay: 2000,
            callback: this.spawnEnemy,
            callbackScope: this,
            loop: true
        });
        console.log('MainScene: Êïå‰∫∫ÁîüÊàêÂô®Â∑≤ÂàõÂª∫');
    }

    shoot(angle = null) {
        if (this.isGameOver || this.scene.isPaused()) return; // Ê∏∏ÊàèÁä∂ÊÄÅÊ£ÄÊü•
        const currentTime = this.time.now;
        // üÜï Ê£ÄÊü•Â≠êÂºπÊòØÂê¶Ë∂≥Â§ü
        if (this.currentWeapon.bulletCost > 0 && this.currentWeapon.bulletCount <= 0) {
            this.showNoBulletsMessage();
            return;
        }
        // üÜï Ê£ÄÊü•ÊôÆÈÄöÂ∞ÑÂáªÂÜ∑Âç¥
        if (currentTime - this.lastShootTime < this.currentWeapon.fireRate) {
            console.log('MainScene: Â∞ÑÂáªÂÜ∑Âç¥‰∏≠');
            return; // ÂÜ∑Âç¥Êó∂Èó¥Êú™Âà∞
        }
        if (!this.player || !this.player.active) {
            console.log('MainScene: Áé©ÂÆ∂‰∏çÂ≠òÂú®ÊàñÊú™ÊøÄÊ¥ª');
            return;
        }
        // üÜï Ê∂àËÄóÂ≠êÂºπ
        if (this.currentWeapon.bulletCost > 0) {
            this.currentWeapon.bulletCount--;
            console.log(`MainScene: Ê∂àËÄó1Âèë${this.currentWeapon.name}Â≠êÂºπÔºåÂâ©‰Ωô${this.currentWeapon.bulletCount}Âèë`);
        }
        this.lastShootTime = currentTime;
        // üÜï ÊâßË°åËøûÂèëÂ∞ÑÂáªÔºå‰º†ÈÄíÂ∞ÑÂáªËßíÂ∫¶
        this.executeBurstFire(angle);
    }
    
    // üÜï ÊâßË°åËøûÂèëÂ∞ÑÂáª
    executeBurstFire(angle = null) {
        const weapon = this.currentWeapon;
        const offsetX = this.playerSize / 2;
        const startX = this.player.x + offsetX;
        const startY = this.player.y;
        
        // üÜï Â¶ÇÊûúÊèê‰æõ‰∫ÜËßíÂ∫¶ÔºàÊù•Ëá™Ëß¶Êë∏ÊéßÂà∂ÔºâÔºå‰ΩøÁî®ÂÆÉÔºõÂê¶ÂàôËÆ°ÁÆóÈº†Ê†áËßíÂ∫¶
        if (angle === null) {
            angle = Phaser.Math.Angle.Between(
                startX, startY,
                this.input.activePointer.worldX,
                this.input.activePointer.worldY
            );
        }
        
        // üÜï Âä†ÁâπÊûóÊâáÂΩ¢Êï£Âºπ
        if (weapon.name === 'Âä†ÁâπÊûó') {
            const spreadAngle = Math.PI / 4; // 45Â∫¶ÊâáÂΩ¢
            const bulletCount = 8; // Âõ∫ÂÆö8ÂèëÂ≠êÂºπ
            const angleStep = spreadAngle / (bulletCount - 1);
            const startAngle = angle - spreadAngle / 2;
            
            // üÜï ÂêåÊó∂ÂèëÂ∞Ñ8ÂèëÊâáÂΩ¢Êï£Âºπ
            for (let i = 0; i < bulletCount; i++) {
                const bulletAngle = startAngle + angleStep * i;
                // ÁßªÈô§Âª∂ËøüÔºåÊâÄÊúâÂ≠êÂºπÂêåÊó∂ÂèëÂ∞Ñ
                if (!this.isGameOver && this.player && this.player.active) {
                    this.fireSingleBullet(startX, startY, bulletAngle, weapon);
                }
            }
            
            console.log(`MainScene: ÂèëÂ∞Ñ${weapon.name}ÔºåÂêåÊó∂ÊâáÂΩ¢Êï£Âºπ${bulletCount}ÂèëÔºåËßíÂ∫¶ËåÉÂõ¥${spreadAngle * 180 / Math.PI}Â∫¶`);
        } else {
            // ÂÖ∂‰ªñÊ≠¶Âô®ÁöÑÊôÆÈÄöËøûÂèë
            // ÂèëÂ∞ÑÁ¨¨‰∏ÄÂèë
            this.fireSingleBullet(startX, startY, angle, weapon);
            
            // Â¶ÇÊûúÊúâËøûÂèëÔºåÁªßÁª≠ÂèëÂ∞Ñ
            if (weapon.burstCount > 1) {
                for (let i = 1; i < weapon.burstCount; i++) {
                    this.time.delayedCall(weapon.burstDelay * i, () => {
                        if (!this.isGameOver && this.player && this.player.active) {
                            this.fireSingleBullet(startX, startY, angle, weapon);
                        }
                    }, null, this);
                }
            }
            
            console.log(`MainScene: ÂèëÂ∞Ñ${weapon.name}ÔºåËøûÂèë${weapon.burstCount}Âèë`);
        }
    }
    
    // üÜï ÂèëÂ∞ÑÂçïÂèëÂ≠êÂºπ
    fireSingleBullet(x, y, angle, weapon) {
        const bullet = this.bullets.get();
        if (bullet) {
            bullet.fire(x, y, weapon);
            
            // üîä Êí≠ÊîæÂ∞ÑÂáªÈü≥Êïà
            if (this.audioManager) {
                this.audioManager.play('shoot');
            }
            
            // üÜï Â∞ÑÂáªÁ≤íÂ≠êÊïàÊûú
            this.shootEmitter.setPosition(x, y);
            this.shootEmitter.start();
            this.time.delayedCall(100, () => {
                this.shootEmitter.stop();
            });
            
            // üÜï ÁâπÊÆäÊ≠¶Âô®ÊïàÊûú
            if (weapon.name === 'Â£∞Ê≥¢Êû™' && weapon.isContinuous) {
                this.executeTeslaBeam(bullet);
            }
            
            // üÜï Ê†∏ÂºπËøΩË∏™ÂäüËÉΩ
            if (weapon.name === 'Ê†∏Âºπ' && weapon.config && weapon.config.isHoming) {
                this.setupNuclearHoming(bullet);
            }
        }
    }
    
        // üÜï Ê†∏ÂºπËøΩË∏™ÂäüËÉΩ
    setupNuclearHoming(bullet) {
        console.log('ËÆæÁΩÆÊ†∏ÂºπËøΩË∏™ÂäüËÉΩ');
        
        // ËÆæÁΩÆÊ†∏ÂºπËøΩË∏™ÊúÄËøëÁöÑÊïå‰∫∫
        bullet.update = () => {
            if (!bullet.active) return;
            
            // ÂØªÊâæÊúÄËøëÁöÑÊïå‰∫∫
            const enemies = this.enemies.getChildren();
            let nearestEnemy = null;
            let nearestDistance = Infinity;
            
            for (let enemy of enemies) {
                if (enemy.active) {
                    const distance = Phaser.Math.Distance.Between(bullet.x, bullet.y, enemy.x, enemy.y);
                    if (distance < nearestDistance) {
                        nearestDistance = distance;
                        nearestEnemy = enemy;
                    }
                }
            }
            
            // Â¶ÇÊûúÊâæÂà∞Êïå‰∫∫ÔºåË∞ÉÊï¥Ê†∏ÂºπÊñπÂêë
            if (nearestEnemy) {
                const angle = Phaser.Math.Angle.Between(bullet.x, bullet.y, nearestEnemy.x, nearestEnemy.y);
                const speed = bullet.body.velocity.length();
                
                // Âπ≥ÊªëËøΩË∏™ÔºöÈÄêÊ∏êË∞ÉÊï¥ÊñπÂêëËÄå‰∏çÊòØÁû¨Èó¥ÊîπÂèò
                const currentAngle = Math.atan2(bullet.body.velocity.y, bullet.body.velocity.x);
                const angleDiff = Phaser.Math.Angle.Wrap(angle - currentAngle);
                const maxTurnRate = 0.15; // Â¢ûÂä†ËΩ¨ÂêëÈÄüÁéá
                const turnRate = Phaser.Math.Clamp(angleDiff, -maxTurnRate, maxTurnRate);
                const newAngle = currentAngle + turnRate;
                
                this.physics.velocityFromRotation(newAngle, speed, bullet.body.velocity);
                
                // Ê∑ªÂä†ËøΩË∏™ËßÜËßâÊïàÊûú
                bullet.setRotation(newAngle);
                
                // Ê∑ªÂä†ËøΩË∏™ËΩ®ËøπÊïàÊûú
                if (Math.random() < 0.5) { // Â¢ûÂä†ËΩ®ËøπÊ¶ÇÁéá
                    this.add.particles('nuke').createEmitter({
                        x: bullet.x,
                        y: bullet.y,
                        speed: { min: 10, max: 30 },
                        scale: { start: 0.3, end: 0 },
                        alpha: { start: 0.5, end: 0 },
                        lifespan: 300,
                        quantity: 1
                    });
                }
            }
        };
    }
    
    // üÜï Ê†∏ÂºπÁàÜÁÇ∏ÊïàÊûúÔºàÊîπËøõÁâàÔºâ
    // üÜï Ê†∏ÂºπÁàÜÁÇ∏ÊïàÊûúÔºàÂÆåÂÖ®ÈáçÂÜôÔºåÂ¢ûÂä†ÂÖ®Â±èÁâπÊïàÔºâ
    executeNuclearStrike(bullet, hitEnemy) {
        const weapon = this.weapons.find(w => w.name === 'Ê†∏Âºπ');
      
        // üîß ‰øÆÂ§çÁàÜÁÇ∏‰∏≠ÂøÉÂùêÊ†áËÆ°ÁÆó
        const explosionCenter = hitEnemy ? 
            { x: hitEnemy.x, y: hitEnemy.y } : 
            { x: bullet.x, y: bullet.y };
      
        const explosionRadius = (weapon && weapon.config && weapon.config.damageRadius) ? 
            weapon.config.damageRadius : 400;
      
        console.log(`üî• Ê†∏ÂºπÁàÜÁÇ∏ÂºÄÂßãÔºö‰∏≠ÂøÉ(${explosionCenter.x}, ${explosionCenter.y})ÔºåÂçäÂæÑ${explosionRadius}`);
      
        // üÜï Á´ãÂç≥ÂºÄÂßãÂÖ®Â±èÁâπÊïà
        this.createNuclearExplosionEffects(explosionCenter);
      
        let killedEnemies = 0;
        const enemies = this.enemies.getChildren();
        const totalEnemies = enemies.filter(e => e.active).length;
      
        console.log(`Ê†∏ÂºπÁàÜÁÇ∏ÂâçÊÄªÊïå‰∫∫Êï∞ÈáèÔºö${totalEnemies}`);
      
        // üÜï Âª∂ËøüÁàÜÁÇ∏‰º§ÂÆ≥ÔºåÈÖçÂêàËßÜËßâÊïàÊûú
        this.time.delayedCall(300, () => {
            for (let enemy of enemies) {
                if (enemy.active) {
                    const distance = Phaser.Math.Distance.Between(
                        explosionCenter.x, explosionCenter.y, 
                        enemy.x, enemy.y
                    );
                    const enemyName = enemy.enemyData ? enemy.enemyData.name : 'Unknown';
                  
                    if (distance <= explosionRadius) {
                        killedEnemies++;
                        this.killCount++;
                      
                        // üÜï Â¢ûÂä†Ê†∏ÂºπÁâπÊÆäÂæóÂàÜ
                        const baseScore = 150; // Ê†∏ÂºπÂü∫Á°ÄÂàÜÊï∞Êõ¥È´ò
                        const distanceFactor = Math.max(0.3, 1 - distance / explosionRadius);
                        const scoreGain = Math.floor(baseScore * distanceFactor);
                        this.score += scoreGain;
                      
                        console.log(`‚ò¢Ô∏è Ê†∏ÂºπÂáªÊùÄÔºö${enemyName}ÔºåË∑ùÁ¶ª${distance.toFixed(2)}ÔºåÂæóÂàÜ${scoreGain}`);
                      
                        // üÜï Êïå‰∫∫Ê∂àÂ§±ÁâπÊïà
                        this.createEnemyVaporizeEffect(enemy);
                      
                        enemy.destroy();
                    }
                }
            }
          
            const remainingEnemies = this.enemies.getChildren().filter(e => e.active).length;
            console.log(`‚ò¢Ô∏è Ê†∏ÂºπÁàÜÁÇ∏ÂÆåÊàêÔºöÂáªÊùÄ${killedEnemies}/${totalEnemies}‰∏™Êïå‰∫∫ÔºåÂâ©‰Ωô${remainingEnemies}‰∏™Êïå‰∫∫`);
          
            this.updateHUD();
        });
    }
    
    // üîß ‰øÆÂ§çÂØºÂºπÁàÜÁÇ∏ÊïàÊûúÔºà‰πüÂ¢ûÂº∫‰∏Ä‰∏ãÔºâ
    executeMissileExplosion(bullet, hitEnemy) {
        const weapon = this.weapons.find(w => w.name === 'ÂØºÂºπ');
      
        // üîß ‰øÆÂ§çÁàÜÁÇ∏‰∏≠ÂøÉÂùêÊ†áËÆ°ÁÆó
        const explosionCenter = hitEnemy ? 
            { x: hitEnemy.x, y: hitEnemy.y } : 
            { x: bullet.x, y: bullet.y };
      
        const explosionRadius = (weapon && weapon.config && weapon.config.damageRadius) ? 
            weapon.config.damageRadius : 200;
      
        console.log(`üí• ÂØºÂºπÁàÜÁÇ∏Ôºö‰∏≠ÂøÉ(${explosionCenter.x}, ${explosionCenter.y})ÔºåÂçäÂæÑ${explosionRadius}`);
      
        let killedEnemies = 0;
        const enemies = this.enemies.getChildren();
      
        for (let enemy of enemies) {
            if (enemy.active) {
                const distance = Phaser.Math.Distance.Between(
                    explosionCenter.x, explosionCenter.y, 
                    enemy.x, enemy.y
                );
              
                if (distance <= explosionRadius) {
                    killedEnemies++;
                    this.killCount++;
                    const baseScore = weapon ? weapon.damage : 60;
                    const distanceFactor = Math.max(0.5, 1 - distance / explosionRadius);
                    const scoreGain = Math.floor(baseScore * distanceFactor);
                    this.score += scoreGain;
                  
                    if (this.deathEmitter) {
                        this.deathEmitter.setPosition(enemy.x, enemy.y);
                        this.deathEmitter.start();
                        this.time.delayedCall(100, () => { 
                            if (this.deathEmitter) this.deathEmitter.stop(); 
                        });
                    }
                    enemy.destroy();
                }
            }
        }
      
        // üÜï Â¢ûÂº∫ÂØºÂºπÁàÜÁÇ∏ÁâπÊïà
        this.createMissileExplosionEffect(explosionCenter);
        this.updateHUD();
        // ÁàÜÁÇ∏ÂáªÊùÄÁöÑÊïå‰∫∫‰πüÂèØËÉΩÊéâËêΩÈÅìÂÖ∑
        for (let enemy of enemies) {
            if (enemy.active && distance <= explosionRadius) {
                const enemyType = enemy.enemyData ? enemy.enemyData.name : 'Â∞èÂÖµ';
                if (Math.random() < 0.3) {
                    if (this.powerUpManager) this.powerUpManager.spawnPowerUp(enemy.x, enemy.y, enemyType);
                }
                enemy.destroy();
            }
        }
    }

    // üÜï Â¢ûÂº∫ÂØºÂºπÁàÜÁÇ∏ÁâπÊïà
    createMissileExplosionEffect(center) {
        // ÁàÜÁÇ∏ÁÅ´ÁêÉ
        const fireball = this.add.circle(center.x, center.y, 10, 0xff4400, 0.8)
            .setDepth(400);
      
        this.tweens.add({
            targets: fireball,
            scaleX: 6,
            scaleY: 6,
            alpha: 0,
            duration: 400,
            ease: 'Power2',
            onComplete: () => fireball.destroy()
        });
      
        // ÁàÜÁÇ∏ÂÜ≤ÂáªÊ≥¢
        const shockwave = this.add.graphics().setDepth(399);
        this.tweens.add({
            targets: shockwave,
            duration: 600,
            onUpdate: (tween) => {
                const progress = tween.progress;
                const radius = progress * 250;
                const alpha = 1 - progress;
              
                shockwave.clear();
                shockwave.lineStyle(4, 0xff6600, alpha);
                shockwave.strokeCircle(center.x, center.y, radius);
            },
            onComplete: () => shockwave.destroy()
        });
      
        // Â±èÂπïÈúáÂä®
        this.cameras.main.shake(300, 0.02);
      
        // ÁàÜÁÇ∏Á≤íÂ≠ê
        if (this.explosionEmitter) {
            this.explosionEmitter.setPosition(center.x, center.y);
            this.explosionEmitter.start();
            this.time.delayedCall(300, () => { 
                if (this.explosionEmitter) this.explosionEmitter.stop(); 
            });
        }
    }
    
    // üÜï Â£∞Ê≥¢ÊåÅÁª≠ÊïàÊûú
    executeTeslaBeam(bullet) {
        // Â£∞Ê≥¢ÊåÅÁª≠2Áßí
        this.time.delayedCall(this.currentWeapon.duration, () => {
            if (bullet && bullet.active) {
                bullet.destroy();
            }
        }, null, this);
    }

    // üÜï ÂàõÂª∫Ê†∏ÂºπÁàÜÁÇ∏ÂÖ®Â±èÁâπÊïà
    createNuclearExplosionEffects(explosionCenter) {
        console.log('üéÜ ÂºÄÂßãÊ†∏ÂºπÂÖ®Â±èÁâπÊïà');
      
        // 1. üÜï ÂÖ®Â±èÁôΩÂÖâÈó™ÁÉÅ
        const flashOverlay = this.add.rectangle(640, 360, 1280, 720, 0xffffff, 0.9)
            .setDepth(999);
      
        this.tweens.add({
            targets: flashOverlay,
            alpha: 0,
            duration: 500,
            ease: 'Power2',
            onComplete: () => flashOverlay.destroy()
        });
      
        // 2. üÜï Ê†∏ÁàÜÂÜ≤ÂáªÊ≥¢ÁéØ
        const shockwaveRings = [];
        for (let i = 0; i < 3; i++) {
            const ring = this.add.graphics()
                .setDepth(500);
          
            this.time.delayedCall(i * 100, () => {
                this.tweens.add({
                    targets: ring,
                    duration: 1000,
                    ease: 'Power2',
                    onUpdate: (tween) => {
                        const progress = tween.progress;
                        const radius = progress * 600;
                        const alpha = 1 - progress;
                      
                        ring.clear();
                        ring.lineStyle(8, 0xff6600, alpha);
                        ring.strokeCircle(explosionCenter.x, explosionCenter.y, radius);
                    },
                    onComplete: () => ring.destroy()
                });
            });
          
            shockwaveRings.push(ring);
        }
      
        // 3. üÜï Ê†∏ÁàÜËòëËèá‰∫ëÊïàÊûú
        this.createMushroomCloudEffect(explosionCenter);
      
        // 4. üÜï Â±èÂπïÂâßÁÉàÈúáÂä®
        this.cameras.main.shake(1000, 0.05);
      
        // 5. üÜï ÂÖ®Â±èÊîæÂ∞ÑÊÄßÁ≤íÂ≠ê
        this.createRadiationParticles(explosionCenter);
      
        // 6. üÜï Èü≥ÊïàÂíåÊó∂Èó¥ÂáèÊÖ¢ÊïàÊûú
        this.createNuclearSoundEffect();
        this.createTimeSlowEffect();
    }

    // üÜï ÂàõÂª∫ËòëËèá‰∫ëÊïàÊûú
    createMushroomCloudEffect(center) {
        // ÂàõÂª∫Â§öÂ±ÇËòëËèá‰∫ë
        for (let i = 0; i < 5; i++) {
            const cloud = this.add.circle(
                center.x + Phaser.Math.Between(-50, 50),
                center.y - i * 30,
                20 + i * 10,
                0xff4400,
                0.7
            ).setDepth(400);
          
            // ËòëËèá‰∫ë‰∏äÂçáÂíåÊâ©Êï£Âä®Áîª
            this.tweens.add({
                targets: cloud,
                y: cloud.y - 100,
                scaleX: 2 + i * 0.5,
                scaleY: 1.5 + i * 0.3,
                alpha: 0,
                duration: 2000 + i * 200,
                ease: 'Power2',
                onComplete: () => cloud.destroy()
            });
        }
    }

    // üÜï ÂàõÂª∫ÊîæÂ∞ÑÊÄßÁ≤íÂ≠êÊïàÊûú
    createRadiationParticles(center) {
        // ÂàõÂª∫‰∏¥Êó∂Á≤íÂ≠êÂèëÂ∞ÑÂô®
        const radiationEmitter = this.add.particles(center.x, center.y, 'bullet', {
            speed: { min: 100, max: 400 },
            scale: { start: 0.5, end: 0 },
            alpha: { start: 0.8, end: 0 },
            lifespan: 1500,
            blendMode: 'ADD',
            angle: { min: 0, max: 360 },
            quantity: 3,
            tint: [0xff0000, 0xff6600, 0xffff00, 0x00ff00]
        }).setDepth(600);
      
        // 2ÁßíÂêéÂÅúÊ≠¢Á≤íÂ≠êÊïàÊûú
        this.time.delayedCall(2000, () => {
            radiationEmitter.destroy();
        });
    }

    // üÜï ÂàõÂª∫Êïå‰∫∫Ëí∏ÂèëÊïàÊûú
    createEnemyVaporizeEffect(enemy) {
        // Êïå‰∫∫Ëí∏ÂèëÁ≤íÂ≠ê
        const vaporize = this.add.particles(enemy.x, enemy.y, 'bullet', {
            speed: { min: 50, max: 150 },
            scale: { start: 0.3, end: 0 },
            alpha: { start: 1, end: 0 },
            lifespan: 800,
            blendMode: 'ADD',
            angle: { min: 0, max: 360 },
            quantity: 5,
            tint: 0x00ff00
        });
      
        this.time.delayedCall(1000, () => {
            vaporize.destroy();
        });
    }

    // üÜï ÂàõÂª∫Ê†∏ÂºπÈü≥Êïà
    createNuclearSoundEffect() {
        // Ê®°ÊãüÈü≥ÊïàÔºàÂ¶ÇÊûúÊúâÈü≥È¢ëËµÑÊ∫êÂèØ‰ª•Êí≠ÊîæÁúüÂÆûÈü≥ÊïàÔºâ
        console.log('üîä Êí≠ÊîæÊ†∏ÂºπÁàÜÁÇ∏Èü≥Êïà');
      
        // ÂèØ‰ª•Âú®ËøôÈáåÊ∑ªÂä†ÁúüÂÆûÈü≥ÊïàÊí≠Êîæ
        // this.sound.play('nuclearExplosion');
    }

    // üÜï ÂàõÂª∫Êó∂Èó¥ÂáèÊÖ¢ÊïàÊûú
    createTimeSlowEffect() {
        // Áü≠ÊöÇÂáèÊÖ¢Ê∏∏ÊàèÊó∂Èó¥
        this.physics.world.timeScale = 0.3;
        this.time.timeScale = 0.3;
      
        this.time.delayedCall(500, () => {
            this.physics.world.timeScale = 1;
            this.time.timeScale = 1;
            console.log('‚è∞ Êó∂Èó¥ÊµÅÈÄüÊÅ¢Â§çÊ≠£Â∏∏');
        });
      
        console.log('‚è∞ Êó∂Èó¥ÂáèÊÖ¢ÊïàÊûúÂêØÂä®');
    }
    
    // üÜï ÊòæÁ§∫Â≠êÂºπ‰∏çË∂≥ÊèêÁ§∫
    showNoBulletsMessage() {
        if (this.weaponSwitchText) {
            this.weaponSwitchText.destroy();
        }
        
        this.weaponSwitchText = this.add.text(640, 200, `${this.currentWeapon.name}Â≠êÂºπ‰∏çË∂≥ÔºÅÊåâ${this.currentWeaponIndex + 1}ÈîÆË¥≠‰π∞Â≠êÂºπ`, {
            font: '24px Arial',
            fill: '#ff0000',
            stroke: '#000000',
            strokeThickness: 3
        }).setOrigin(0.5).setScrollFactor(0); // üÜï Ê®™ÁâàÂç∑ËΩ¥ÔºöÂõ∫ÂÆöÊòæÁ§∫
        
        this.time.delayedCall(2000, () => {
            if (this.weaponSwitchText) {
                this.weaponSwitchText.destroy();
                this.weaponSwitchText = null;
            }
        }, null, this);
    }
    
    // üÜï ÊòæÁ§∫Ê≠¶Âô®ÂÜ∑Âç¥ÊèêÁ§∫
    showWeaponCooldownMessage(remainingTime, state = 'ÂÜ∑Âç¥') {
        if (this.weaponSwitchText) {
            this.weaponSwitchText.destroy();
        }
        
        this.weaponSwitchText = this.add.text(640, 200, `Âä†ÁâπÊûó${state}‰∏≠ÔºÅÂâ©‰Ωô${remainingTime}Áßí`, {
            font: '24px Arial',
            fill: '#ff6600',
            stroke: '#000000',
            strokeThickness: 3
        }).setOrigin(0.5).setScrollFactor(0); // üÜï Ê®™ÁâàÂç∑ËΩ¥ÔºöÂõ∫ÂÆöÊòæÁ§∫
        
        this.time.delayedCall(2000, () => {
            if (this.weaponSwitchText) {
                this.weaponSwitchText.destroy();
                this.weaponSwitchText = null;
            }
        }, null, this);
    }

    togglePause() {
        if (this.scene.isPaused()) {
            this.scene.resume();
        } else {
            this.scene.pause();
        }
    }
    
    // Â§ÑÁêÜÈáçÊñ∞ÂºÄÂßãÊ∏∏Êàè
    handleRestart() {
        if (this.isGameOver || this.isLevelCompleted) {
            console.log('MainScene: Ê£ÄÊµãÂà∞RÈîÆÔºåÈáçÊñ∞ÂºÄÂßãÊ∏∏Êàè');
            
            // Â¶ÇÊûúÂú∫ÊôØË¢´ÊöÇÂÅúÔºåÂÖàÊÅ¢Â§ç
            if (this.scene.isPaused()) {
                this.scene.resume();
            }
            
            // ÈáçÊñ∞ÂºÄÂßãÂú∫ÊôØÔºå‰øùÊåÅÂΩìÂâçÂÖ≥Âç°
            this.scene.restart({ 
                player: this.selectedPlayer, 
                level: this.currentLevelIndex 
            });
        }
    }
    
    // üÜï Ê£ÄÊü•ÂÖ≥Âç°ÂÆåÊàêÊù°‰ª∂
    checkLevelComplete() {
        if (this.isGameOver || this.isLevelCompleted) return;
      
        const currentTime = this.time.now;
        const survivalTime = currentTime - this.gameStartTime;
      
        // Ê£ÄÊü•ÁîüÂ≠òÊó∂Èó¥Êù°‰ª∂
        if (survivalTime >= this.levelCompleteTime) {
            this.completeLevel(`ÁîüÂ≠òÊó∂Èó¥ËææÂà∞${this.levelCompleteTime/1000}Áßí`);
            return;
        }
      
        // Ê£ÄÊü•ÂáªÊùÄÊï∞Êù°‰ª∂
        if (this.killCount >= this.levelCompleteKills) {
            this.completeLevel(`ÂáªÊùÄ${this.levelCompleteKills}‰∏™Êïå‰∫∫`);
            return;
        }
    }
    
    // üÜï ÂÆåÊàêÂÖ≥Âç°
    completeLevel(reason) {
        if (this.isLevelCompleted) return;
      
        this.isLevelCompleted = true;
        console.log(`MainScene: ÂÖ≥Âç° ${this.currentLevel.name} ÂÆåÊàêÔºÅÂéüÂõ†: ${reason}`);
      
        this.levelEndTime = this.time.now;
        this.levelComplete = true;
        
        // üÜï Ê®™ÁâàÂç∑ËΩ¥ÔºöBOSSÊàòÊó∂ÈîÅÂÆöÊëÑÂÉèÊú∫
        if (reason.includes('BOSS') || reason.includes('ÁªàÁÇπ')) {
            this.cameras.main.stopFollow();
            console.log('üîí ÊëÑÂÉèÊú∫Â∑≤ÈîÅÂÆöÔºåBOSSÊàòÂºÄÂßã');
        }
      
        // ÂÅúÊ≠¢Êïå‰∫∫ÁîüÊàê
        if (this.enemySpawner) {
            this.enemySpawner.remove();
            this.enemySpawner = null;
        }
      
        // Ê∏ÖÈô§ÊâÄÊúâÊïå‰∫∫ÂíåÂ≠êÂºπ
        this.enemies.clear(true, true);
        this.enemyBullets.clear(true, true);
      
        // ÊòæÁ§∫ÂÖ≥Âç°ÂÆåÊàêÁïåÈù¢
        this.showLevelCompleteScreen(reason);
    }
    
    // üÜï ‰∏ã‰∏ÄÂÖ≥
    nextLevel() {
        console.log('MainScene: ËøõÂÖ•‰∏ã‰∏ÄÂÖ≥');
        
        const nextLevelIndex = this.currentLevelIndex + 1;
        if (nextLevelIndex < LEVELS_CONFIG.length) {
            // Â¶ÇÊûúÂú∫ÊôØË¢´ÊöÇÂÅúÔºåÂÖàÊÅ¢Â§ç
            if (this.scene.isPaused()) {
                this.scene.resume();
            }
            
            // ÂêØÂä®‰∏ã‰∏ÄÂÖ≥
            this.scene.restart({ 
                player: this.selectedPlayer, 
                level: nextLevelIndex 
            });
        } else {
            console.log('MainScene: Â∑≤ÂÆåÊàêÊâÄÊúâÂÖ≥Âç°ÔºÅ');
        }
    }

    // üÜï Âä†ËΩΩÂÖ≥Âç°ÈÖçÁΩÆ
    loadLevelConfig() {
        // ‰ªéLEVELS_CONFIGÂä†ËΩΩÂÖ≥Âç°ÈÖçÁΩÆ
        if (this.currentLevelIndex >= 0 && this.currentLevelIndex < LEVELS_CONFIG.length) {
            this.currentLevel = LEVELS_CONFIG[this.currentLevelIndex];
            console.log(`üéµ Âä†ËΩΩÂÖ≥Âç° ${this.currentLevelIndex + 1}: ${this.currentLevel.name}`);
            
            // üÜï Êí≠ÊîæËÉåÊôØÈü≥‰πê
            if (this.audioManager && this.currentLevel.music) {
                this.audioManager.playBackgroundMusic(this.currentLevel.music);
            }
        } else {
            // ‰ΩøÁî®ÈªòËÆ§ÂÖ≥Âç°ÈÖçÁΩÆ
            this.currentLevel = {
                name: 'Ê®™ÁâàÂç∑ËΩ¥ÊµãËØïÂÖ≥Âç°',
                description: 'ÊµãËØïÊ®™ÁâàÂç∑ËΩ¥Êú∫Âà∂',
                levelDuration: 120000, // 2ÂàÜÈíü
                targetKills: 30,
                spawnRate: 2000,
                maxEnemies: 10,
                environmentEffects: [],
                music: 'city_theme'
            };
            
            // üÜï Êí≠ÊîæÈªòËÆ§ËÉåÊôØÈü≥‰πê
            if (this.audioManager) {
                this.audioManager.playBackgroundMusic('city_theme');
            }
        }
    }

    // üÜï ÊòæÁ§∫ÂÖ≥Âç°ÂºÄÂú∫Âä®Áîª
    showLevelIntro() {
        console.log('MainScene: ÊòæÁ§∫ÂÖ≥Âç°‰ªãÁªç:', this.currentLevel.name);
        
        // ÂàõÂª∫ÂÖ≥Âç°‰ªãÁªçËÉåÊôØÔºàÁ°Æ‰øùÂú®ÊúÄÈ°∂Â±ÇÔºâ
        const introBg = this.add.rectangle(640, 360, 1280, 720, 0x000000, 0.9)
            .setDepth(1000).setScrollFactor(0); // ËÆæÁΩÆÊúÄÈ´òÊ∑±Â∫¶Âπ∂Âõ∫ÂÆöÊòæÁ§∫
      
        // ÂÖ≥Âç°ÂêçÁß∞
        const levelTitle = this.add.text(640, 280, this.currentLevel.name, {
            font: '72px Arial',
            fill: '#ffffff',
            stroke: '#000000',
            strokeThickness: 4
        }).setOrigin(0.5).setAlpha(0).setDepth(1001).setScrollFactor(0);
      
        // ÂÖ≥Âç°ÊèèËø∞
        const levelDesc = this.add.text(640, 360, this.currentLevel.description, {
            font: '24px Arial',
            fill: '#cccccc',
            stroke: '#000000',
            strokeThickness: 2
        }).setOrigin(0.5).setAlpha(0).setDepth(1001).setScrollFactor(0);
      
        // ÂÖ≥Âç°ÁõÆÊ†á
        const targetText = `ÁõÆÊ†á: Âà∞ËææÁªàÁÇπ Êàñ ÁîüÂ≠ò${this.currentLevel.levelDuration/1000}Áßí Êàñ ÂáªÊùÄ${this.currentLevel.targetKills}‰∏™Êïå‰∫∫`;
        const levelTarget = this.add.text(640, 420, targetText, {
            font: '18px Arial',
            fill: '#ffff00',
            stroke: '#000000',
            strokeThickness: 1
        }).setOrigin(0.5).setAlpha(0).setDepth(1001).setScrollFactor(0);
      
        // ÂºÄÂßãÊèêÁ§∫
        const startHint = this.add.text(640, 480, '3ÁßíÂêéÂºÄÂßã...', {
            font: '20px Arial',
            fill: '#00ff00',
            stroke: '#000000',
            strokeThickness: 2
        }).setOrigin(0.5).setAlpha(0).setDepth(1001).setScrollFactor(0);
      
        // ÂÄíËÆ°Êó∂ÊòæÁ§∫
        let countdown = 3;
        const countdownText = this.add.text(640, 520, `${countdown}`, {
            font: '36px Arial',
            fill: '#ff0000',
            stroke: '#ffffff',
            strokeThickness: 3
        }).setOrigin(0.5).setAlpha(0).setDepth(1001).setScrollFactor(0);
      
        // Âä®ÁîªÂ∫èÂàó
        this.tweens.add({
            targets: levelTitle,
            alpha: 1,
            duration: 500,
            onComplete: () => {
                this.tweens.add({
                    targets: levelDesc,
                    alpha: 1,
                    duration: 500,
                    onComplete: () => {
                        this.tweens.add({
                            targets: levelTarget,
                            alpha: 1,
                            duration: 500,
                            onComplete: () => {
                                this.tweens.add({
                                    targets: [startHint, countdownText],
                                    alpha: 1,
                                    duration: 500
                                });
                            }
                        });
                    }
                });
            }
        });
      
        // ÂÄíËÆ°Êó∂Êõ¥Êñ∞
        const countdownTimer = this.time.addEvent({
            delay: 1000,
            callback: () => {
                countdown--;
                if (countdown > 0) {
                    countdownText.setText(`${countdown}`);
                    // ÂÄíËÆ°Êó∂Èó™ÁÉÅÊïàÊûú
                    this.tweens.add({
                        targets: countdownText,
                        scaleX: 1.2,
                        scaleY: 1.2,
                        duration: 200,
                        yoyo: true
                    });
                }
            },
            loop: true
        });
      
        // 3ÁßíÂêéÈöêËóè‰ªãÁªç
        this.time.delayedCall(3000, () => {
            countdownTimer.remove(); // ÂÅúÊ≠¢ÂÄíËÆ°Êó∂
            this.tweens.add({
                targets: [introBg, levelTitle, levelDesc, levelTarget, startHint, countdownText],
                alpha: 0,
                duration: 500,
                onComplete: () => {
                    introBg.destroy();
                    levelTitle.destroy();
                    levelDesc.destroy();
                    levelTarget.destroy();
                    startHint.destroy();
                    countdownText.destroy();
                    console.log('MainScene: ÂÖ≥Âç°‰ªãÁªçÁªìÊùüÔºåÊ∏∏ÊàèÂºÄÂßã');
                }
            });
        });
    }

    initLevelSystem() {
        this.gameStartTime = this.time.now;
        this.killCount = 0;
        this.levelCompleteTime = this.currentLevel.levelDuration;
        this.levelCompleteKills = this.currentLevel.targetKills;
        this.levelEndTime = null;
        this.levelComplete = false;
        this.isLevelCompleted = false;
        this.enemySpawnRate = this.currentLevel.spawnRate;
        this.maxEnemies = this.currentLevel.maxEnemies;
        this.currentEnemyCount = 0;
    }

    createLevelBackground() {
        // ÁÆÄÂåñÁöÑÊ®™ÁâàÂç∑ËΩ¥ËÉåÊôØ
        const graphics = this.add.graphics();
      
        // Â§©Á©∫Ê∏êÂèò
        graphics.fillGradientStyle(0x87CEEB, 0x87CEEB, 0xF0F8FF, 0xF0F8FF, 1);
        graphics.fillRect(0, 0, 4000, 400);
      
        // Âú∞Èù¢
        graphics.fillStyle(0x228B22);
        graphics.fillRect(0, 400, 4000, 320);
      
        graphics.setDepth(-100);
        graphics.setScrollFactor(0.3); // ËÉåÊôØËßÜÂ∑ÆÊïàÊûú
      
        console.log('üåÑ Ê®™ÁâàÂç∑ËΩ¥ËÉåÊôØÂàõÂª∫ÂÆåÊàê');
    }

    // üé® ÂàõÂª∫ÂÉèÁ¥†Ëâ∫ÊúØËÉåÊôØ
    createPixelArtBackground() {
        // Ê†πÊçÆÂÖ≥Âç°Á¥¢ÂºïÈÄâÊã©‰∏ªÈ¢ò
        const levelIndex = this.currentLevelIndex + 1;
        const theme = LEVEL_THEMES[levelIndex] || LEVEL_THEMES[1];
        
        // ÂàõÂª∫ËÉåÊôØÂõæÂΩ¢
        const graphics = this.add.graphics();
        
        // ÂàÜÂ±ÇÊ∏êÂèòÂ§©Á©∫ËÉåÊôØÔºàPhaserÂÖºÂÆπÔºâ
        const gradientHeight = 400;
        const colorCount = theme.bgColors.length;
        const segmentHeight = gradientHeight / (colorCount - 1);
        
        for (let i = 0; i < colorCount - 1; i++) {
            const startY = i * segmentHeight;
            const endY = (i + 1) * segmentHeight;
            const startColor = this.hexToRgb(theme.bgColors[i]);
            const endColor = this.hexToRgb(theme.bgColors[i + 1]);
            
            // ÂàõÂª∫Ê∏êÂèòÊïàÊûú
            for (let y = startY; y < endY; y++) {
                const ratio = (y - startY) / segmentHeight;
                const color = this.interpolateColor(startColor, endColor, ratio);
                graphics.fillStyle(color);
                graphics.fillRect(0, y, 4000, 1);
            }
        }
        
        // ËßÜÂ∑ÆËÉåÊôØÂ±Ç
        this.createParallaxLayers(graphics, theme);
        
        // Âú∞Èù¢
        graphics.fillStyle(this.hexToRgb(theme.groundColor));
        graphics.fillRect(0, 400, 4000, 320);
        
        graphics.setDepth(-100);
    }

    // üé® È¢úËâ≤ËΩ¨Êç¢ÂíåÊèíÂÄºÂáΩÊï∞
    hexToRgb(hex) {
        const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
        return result ? {
            r: parseInt(result[1], 16),
            g: parseInt(result[2], 16),
            b: parseInt(result[3], 16)
        } : { r: 0, g: 0, b: 0 };
    }

    interpolateColor(color1, color2, ratio) {
        const r = Math.round(color1.r + (color2.r - color1.r) * ratio);
        const g = Math.round(color1.g + (color2.g - color1.g) * ratio);
        const b = Math.round(color1.b + (color2.b - color1.b) * ratio);
        return (r << 16) | (g << 8) | b;
    }

    // üé® ÂàõÂª∫ËßÜÂ∑ÆËÉåÊôØÂ±Ç
    createParallaxLayers(graphics, theme) {
        // ËøúÊôØÂ±Ç
        graphics.fillStyle(0x222222);
        for (let i = 0; i < 20; i++) {
            const x = i * 200;
            graphics.fillRect(x, 300, 60, 100);
        }
        
        // ‰∏≠ÊôØÂ±Ç
        graphics.fillStyle(0x444444);
        for (let i = 0; i < 33; i++) {
            const x = i * 120;
            graphics.fillRect(x, 350, 40, 50);
        }
        
        // ËøëÊôØÂ±Ç
        graphics.fillStyle(0x666666);
        for (let i = 0; i < 50; i++) {
            const x = i * 80;
            graphics.fillRect(x, 380, 20, 20);
        }
    }

    // 1. ÁßëÊäÄÁΩëÊ†ºËÉåÊôØÔºà‰øÆÊ≠£ÁâàÔºâ
    generateTechGridBackground() {
        const graphics = this.add.graphics();
        graphics.fillStyle(0xe6f3ff);
        graphics.fillRect(0, 0, 1280, 720);
        for (let i = 0; i < 10; i++) {
            const alpha = 0.1 - (i * 0.01);
            graphics.fillStyle(0xccddff, alpha);
            graphics.fillRect(0, i * 72, 1280, 72);
        }
        graphics.lineStyle(1, 0x99ccff, 0.3);
        const gridSize = 40;
        for (let x = 0; x <= 1280; x += gridSize) {
            graphics.beginPath();
            graphics.moveTo(x, 0);
            graphics.lineTo(x, 720);
            graphics.strokePath();
        }
        for (let y = 0; y <= 720; y += gridSize) {
            graphics.beginPath();
            graphics.moveTo(0, y);
            graphics.lineTo(1280, y);
            graphics.strokePath();
        }
        graphics.fillStyle(0x6699ff, 0.4);
        for (let i = 0; i < 20; i++) {
            const x = Phaser.Math.Between(0, 1280);
            const y = Phaser.Math.Between(0, 720);
            graphics.fillCircle(x, y, 2);
            graphics.lineStyle(1, 0x6699ff, 0.3);
            graphics.beginPath();
            graphics.moveTo(x - 5, y);
            graphics.lineTo(x + 5, y);
            graphics.moveTo(x, y - 5);
            graphics.lineTo(x, y + 5);
            graphics.strokePath();
        }
        graphics.setDepth(-100);
    }

    // 2. ‰∫ëÊúµËÉåÊôØÔºà‰øÆÊ≠£ÁâàÔºâ
    generateCloudBackground() {
        const graphics = this.add.graphics();
        graphics.fillStyle(0xf0f8ff);
        graphics.fillRect(0, 0, 1280, 720);
        for (let i = 0; i < 20; i++) {
            const alpha = 0.05 - (i * 0.002);
            graphics.fillStyle(0xe0e6ff, alpha);
            graphics.fillRect(0, i * 36, 1280, 36);
        }
        graphics.fillStyle(0xffffff, 0.6);
        for (let i = 0; i < 15; i++) {
            const cloudX = Phaser.Math.Between(0, 1280);
            const cloudY = Phaser.Math.Between(50, 400);
            const cloudSize = Phaser.Math.Between(30, 80);
            this.drawCloud(graphics, cloudX, cloudY, cloudSize);
        }
        graphics.setDepth(-100);
    }

    // 3. ÁîµË∑ØÊùøËÉåÊôØÔºà‰øÆÊ≠£ÁâàÔºâ
    generateCircuitBackground() {
        const graphics = this.add.graphics();
        graphics.fillStyle(0xf0fff0);
        graphics.fillRect(0, 0, 1280, 720);
        graphics.lineStyle(2, 0x90ee90, 0.6);
        for (let i = 0; i < 30; i++) {
            const startX = Phaser.Math.Between(0, 1280);
            const startY = Phaser.Math.Between(0, 720);
            const endX = startX + Phaser.Math.Between(-200, 200);
            const endY = startY + Phaser.Math.Between(-200, 200);
            graphics.beginPath();
            graphics.moveTo(startX, startY);
            graphics.lineTo(endX, startY);
            graphics.lineTo(endX, endY);
            graphics.strokePath();
            graphics.fillStyle(0x32cd32, 0.8);
            graphics.fillCircle(startX, startY, 3);
            graphics.fillCircle(endX, startY, 3);
            graphics.fillCircle(endX, endY, 3);
        }
        graphics.fillStyle(0x98fb98, 0.4);
        graphics.lineStyle(1, 0x32cd32, 0.8);
        for (let i = 0; i < 10; i++) {
            const rectX = Phaser.Math.Between(50, 1200);
            const rectY = Phaser.Math.Between(50, 650);
            const rectW = Phaser.Math.Between(20, 60);
            const rectH = Phaser.Math.Between(15, 40);
            graphics.fillRect(rectX, rectY, rectW, rectH);
            graphics.strokeRect(rectX, rectY, rectW, rectH);
            for (let j = 0; j < 4; j++) {
                graphics.fillStyle(0x32cd32, 1);
                graphics.fillRect(rectX - 5, rectY + (j + 1) * (rectH / 5), 10, 2);
                graphics.fillRect(rectX + rectW - 5, rectY + (j + 1) * (rectH / 5), 10, 2);
            }
        }
        graphics.setDepth(-100);
    }

    // 4. ÊòüÁ©∫ËÉåÊôØÔºà‰øÆÊ≠£ÁâàÔºâ
    generateStarFieldBackground() {
        const graphics = this.add.graphics();
        graphics.fillStyle(0xf8f8ff);
        graphics.fillRect(0, 0, 1280, 720);
        for (let radius = 500; radius > 0; radius -= 50) {
            const alpha = (500 - radius) / 500 * 0.1;
            graphics.fillStyle(0xe6e6fa, alpha);
            graphics.fillCircle(640, 360, radius);
        }
        for (let i = 0; i < 100; i++) {
            const x = Phaser.Math.Between(0, 1280);
            const y = Phaser.Math.Between(0, 720);
            const size = Phaser.Math.Between(1, 3);
            const alpha = Math.random() * 0.8 + 0.2;
            graphics.fillStyle(0xdda0dd, alpha);
            graphics.fillCircle(x, y, size);
            if (size >= 2) {
                graphics.lineStyle(1, 0xdda0dd, alpha * 0.5);
                graphics.beginPath();
                graphics.moveTo(x - size * 2, y);
                graphics.lineTo(x + size * 2, y);
                graphics.moveTo(x, y - size * 2);
                graphics.lineTo(x, y + size * 2);
                graphics.strokePath();
                }
            }
        graphics.setDepth(-100);
    }

    // 5. ÂÖ≠ËßíÂΩ¢ÁßëÊäÄËÉåÊôØÔºà‰øùÊåÅ‰∏çÂèòÔºâ
    generateHexagonBackground() {
        const graphics = this.add.graphics();
        graphics.fillStyle(0xf5f5f5);
        graphics.fillRect(0, 0, 1280, 720);
        const hexSize = 30;
        const hexWidth = hexSize * Math.sqrt(3);
        const hexHeight = hexSize * 2;
        graphics.lineStyle(1, 0xd3d3d3, 0.8);
        for (let row = 0; row < Math.ceil(720 / (hexHeight * 0.75)) + 1; row++) {
            for (let col = 0; col < Math.ceil(1280 / hexWidth) + 1; col++) {
                const x = col * hexWidth + (row % 2) * (hexWidth / 2);
                const y = row * hexHeight * 0.75;
                this.drawHexagon(graphics, x, y, hexSize);
            }
        }
        graphics.fillStyle(0xe0e0e0, 0.5);
        for (let i = 0; i < 20; i++) {
            const randomRow = Phaser.Math.Between(0, Math.ceil(720 / (hexHeight * 0.75)));
            const randomCol = Phaser.Math.Between(0, Math.ceil(1280 / hexWidth));
            const x = randomCol * hexWidth + (randomRow % 2) * (hexWidth / 2);
            const y = randomRow * hexHeight * 0.75;
            this.fillHexagon(graphics, x, y, hexSize);
        }
        graphics.setDepth(-100);
    }

    // 6. Ê≥¢Êµ™ËÉåÊôØÔºà‰øÆÊ≠£ÁâàÔºâ
    generateWaveBackground() {
        const graphics = this.add.graphics();
        graphics.fillStyle(0xf0ffff);
        graphics.fillRect(0, 0, 1280, 720);
        for (let i = 0; i < 15; i++) {
            const alpha = 0.08 - (i * 0.005);
            graphics.fillStyle(0xe0f6ff, alpha);
            graphics.fillRect(0, i * 48, 1280, 48);
        }
        const waveColors = [0xb0e0e6, 0x87ceeb, 0x87cefa];
        const waveAlphas = [0.3, 0.2, 0.1];
        for (let layer = 0; layer < 3; layer++) {
            graphics.fillStyle(waveColors[layer], waveAlphas[layer]);
            const amplitude = 30 + layer * 20;
            const frequency = 0.01 + layer * 0.005;
            const yOffset = 200 + layer * 150;
            graphics.beginPath();
            graphics.moveTo(0, yOffset);
            for (let x = 0; x <= 1280; x += 5) {
                const y = yOffset + Math.sin(x * frequency) * amplitude;
                graphics.lineTo(x, y);
            }
            graphics.lineTo(1280, 720);
            graphics.lineTo(0, 720);
            graphics.closePath();
            graphics.fillPath();
        }
        graphics.setDepth(-100);
        }
      
    // ÁÆÄÂåñÁâàËÉåÊôØÔºàÈôçÁ∫ßÊñπÊ°àÔºâ
    generateSimpleBackground() {
        const graphics = this.add.graphics();
        graphics.fillStyle(0xf0f8ff);
        graphics.fillRect(0, 0, 1280, 720);
        graphics.fillStyle(0xb0c4de, 0.3);
        for (let i = 0; i < 50; i++) {
            const x = Phaser.Math.Between(0, 1280);
            const y = Phaser.Math.Between(0, 720);
            const size = Phaser.Math.Between(2, 8);
            graphics.fillCircle(x, y, size);
        }
        graphics.lineStyle(1, 0xb0c4de, 0.2);
        for (let i = 0; i < 20; i++) {
            const x1 = Phaser.Math.Between(0, 1280);
            const y1 = Phaser.Math.Between(0, 720);
            const x2 = x1 + Phaser.Math.Between(-100, 100);
            const y2 = y1 + Phaser.Math.Between(-100, 100);
            graphics.beginPath();
            graphics.moveTo(x1, y1);
            graphics.lineTo(x2, y2);
            graphics.strokePath();
        }
        graphics.setDepth(-100);
    }

    // üÜï Ê∑ªÂä†ÁéØÂ¢ÉÊïàÊûú
    addEnvironmentEffects() {
        this.currentLevel.environmentEffects.forEach(effect => {
            switch (effect) {
                case 'sandstorm':
                    this.createSandstormEffect();
                    break;
                case 'fog':
                    this.createFogEffect();
                    break;
                case 'bubbles':
                    this.createBubblesEffect();
                    break;
                case 'stars':
                    this.createStarsEffect();
                    break;
                // Êõ¥Â§öÊïàÊûú...
            }
        });
    }

    // üÜï ÂàõÂª∫ÂÖ≥Âç°ÂØπÂ∫îÁöÑÁé©ÂÆ∂ÔºàÊ®™ÁâàÂç∑ËΩ¥ÁâàÊú¨Ôºâ
    createLevelPlayer() {
        // üé® ‰ΩøÁî®ÂÉèÁ¥†Ëâ∫ÊúØËßíËâ≤Á∫πÁêÜ
        let characterType = 'warrior';
        
        if (this.selectedPlayer && this.selectedPlayer.key) {
            const characterMap = {
                'elf': 'archer',
                'soldier': 'warrior', 
                'diver': 'mage',
                'tank': 'tank',
                'spaceship': 'assassin'
            };
            characterType = characterMap[this.selectedPlayer.key] || 'warrior';
        }
        
        const playerTexture = `${characterType}_0`;
        this.playerSpeed = (this.selectedPlayer && this.selectedPlayer.speed) || 400;
        this.playerSize = 40;
        
        // üÜï Ê®™ÁâàÂç∑ËΩ¥ÔºöÁé©ÂÆ∂Âú®‰∏ñÁïåÂùêÊ†á‰∏≠ÁöÑËµ∑Âßã‰ΩçÁΩÆ
        this.player = this.physics.add.sprite(100, 360, playerTexture)
            .setCollideWorldBounds(true)
            .setDisplaySize(this.playerSize, this.playerSize);
      
        this.player.playerSpeed = this.playerSpeed;
        this.player.isInvincible = false;
        this.player.characterType = characterType;
        this.player.animationFrame = 0;
        
        // üé® ËÆæÁΩÆËßíËâ≤Âä®Áîª
        this.player.animationTimer = this.time.addEvent({
            delay: 200,
            callback: this.updatePlayerAnimation,
            callbackScope: this,
            loop: true
        });
        
        // üÜï Ê®™ÁâàÂç∑ËΩ¥ÔºöËÆæÁΩÆÊëÑÂÉèÊú∫Ë∑üÈöèÁé©ÂÆ∂
        this.cameras.main.startFollow(this.player);
        this.cameras.main.setLerp(0.1, 0.1); // Âπ≥ÊªëË∑üÈöè
        this.cameras.main.setDeadzone(200, 100); // Ê≠ªÂå∫ËÆæÁΩÆ
  
        console.log('üéÆ Ê®™ÁâàÂç∑ËΩ¥Áé©ÂÆ∂ÂàõÂª∫ÂÆåÊàêÔºåÁ±ªÂûã:', characterType);
    }

    startLevelEnemySpawner() {
        this.enemySpawner = this.time.addEvent({
            delay: this.enemySpawnRate,
            callback: this.spawnLevelEnemy,
            callbackScope: this,
            loop: true
        });
    }

    // üé® Êõ¥Êñ∞Áé©ÂÆ∂Âä®Áîª
    updatePlayerAnimation() {
        if (!this.player || !this.player.active) return;
        
        this.player.animationFrame = (this.player.animationFrame + 1) % 4;
        const newTexture = `${this.player.characterType}_${this.player.animationFrame}`;
        
        if (this.textures.exists(newTexture)) {
            this.player.setTexture(newTexture);
        }
    }

    // üé® Êõ¥Êñ∞Êïå‰∫∫Âä®Áîª
    updateEnemyAnimation(enemy) {
        if (!enemy || !enemy.active) return;
        
        enemy.animationFrame = (enemy.animationFrame + 1) % 4;
        const newTexture = `${enemy.pixelType}_${enemy.animationFrame}`;
        
        if (this.textures.exists(newTexture)) {
            enemy.setTexture(newTexture);
        }
    }

    // üÜï ÁîüÊàêÂÖ≥Âç°Êïå‰∫∫
    spawnLevelEnemy() {
        if (this.isGameOver || this.currentEnemyCount >= this.maxEnemies) return;
      
        // ‰ΩøÁî®ÁÆÄÂçïÊïå‰∫∫Á±ªÂûã
        const enemyTypes = ['enemy'];
        const enemyType = enemyTypes[Math.floor(Math.random() * enemyTypes.length)];
        const enemyTexture = enemyType;
      
        const y = Phaser.Math.Between(50, 670);
        // üÜï Ê®™ÁâàÂç∑ËΩ¥ÔºöÂú®ÊëÑÂÉèÊú∫Âè≥‰æßÁîüÊàêÊïå‰∫∫
        const spawnX = this.cameras.main.scrollX + 900;
        const enemy = this.enemies.create(spawnX, y, enemyTexture);
      
        if (enemy) {
            enemy.setDisplaySize(32, 32);
            enemy.setVelocityX(-100); // ÂêëÂ∑¶ÁßªÂä®ÔºàÁõ∏ÂØπ‰∏ñÁïåÂùêÊ†áÔºâ
          
            if (enemy.body) {
                enemy.body.enable = true;
            }
          
            // üÜï ËÆæÁΩÆÊïå‰∫∫Êï∞ÊçÆ
            enemy.enemyData = {
                name: 'Â∞èÂÖµ',
                ai: 'straight',
                weight: 1
            };
          
            enemy.checkBounds = true;
            this.currentEnemyCount++;
            
            console.log(`MainScene: Ê®™ÁâàÂç∑ËΩ¥Êïå‰∫∫ÁîüÊàêÊàêÂäüÔºå‰ΩçÁΩÆ: (${enemy.x}, ${enemy.y})ÔºåÂΩìÂâçÊïå‰∫∫Êï∞Èáè: ${this.currentEnemyCount}/${this.maxEnemies}`);
        } else {
            console.error('MainScene: Êó†Ê≥ïÂàõÂª∫Êïå‰∫∫ÂØπË±°');
        }
    }

    // üÜï Ê†πÊçÆÊùÉÈáçÈÄâÊã©Êïå‰∫∫Á±ªÂûã
    selectEnemyType() {
        const enemies = this.currentLevel.enemies;
        let totalWeight = enemies.reduce((sum, enemy) => sum + enemy.weight, 0);
        let random = Math.random() * totalWeight;
      
        for (let enemy of enemies) {
            random -= enemy.weight;
            if (random <= 0) {
                return enemy;
            }
        }
      
        return enemies[0]; // Â§áÁî®
    }

    // üÜï Â§ÑÁêÜÊïå‰∫∫Â≠êÂºπÂáª‰∏≠Áé©ÂÆ∂
    handleEnemyBulletHit(player, bullet) {
        if (player.isInvincible) return;
      
        bullet.destroy();
      
        // Â≠êÂºπ‰º§ÂÆ≥
        const bulletDamage = bullet.damage || 15;
        this.currentHealth -= bulletDamage;
      
        if (this.currentHealth < 0) {
            this.currentHealth = 0;
        }
      
        console.log(`MainScene: Áé©ÂÆ∂Ë¢´Êïå‰∫∫Â≠êÂºπÂáª‰∏≠ÔºåÊâ£Ë°Ä ${bulletDamage}ÔºåÂΩìÂâçË°ÄÈáè: ${this.currentHealth}/${this.maxHealth}`);
      
        // ÊòæÁ§∫Âèó‰º§ÊïàÊûú
        this.showDamageEffect(bulletDamage, 'bullet');
        this.updateHUD();
      
        // ËÆæÁΩÆÊó†ÊïåÁä∂ÊÄÅ
        player.isInvincible = true;
        player.setTint(0xff0000);
        this.time.delayedCall(this.invincibilityTime, () => {
            if (player && player.active) {
                player.isInvincible = false;
                player.clearTint();
            }
        });
      
        if (this.currentHealth <= 0) {
            this.gameOver();
        }
    }

    // üîß Êñ∞Â¢ûÊïå‰∫∫Ê≠ª‰∫°Â§ÑÁêÜÊñπÊ≥ï
    handleEnemyDeath(deathData) {
        console.log(`MainScene: Êïå‰∫∫Ê≠ª‰∫°‰∫ã‰ª∂ - ${deathData.enemyName}, ÂæóÂàÜ: ${deathData.score}`);
      
        // Â¢ûÂä†ÂàÜÊï∞ÂíåÂáªÊùÄÊï∞
        this.score += deathData.score;
        this.killCount++;
        this.currentEnemyCount--;
      
        // üìä ËÆ∞ÂΩïÁªüËÆ°
        if (window.StatsManager) {
            window.StatsManager.addKill();
            window.StatsManager.addScore(deathData.score);
        }
        
        // üèÜ Ê£ÄÊü•ÊàêÂ∞±
        if (window.AchievementManager) {
            window.AchievementManager.checkAchievements();
        }
      
        // Êõ¥Êñ∞HUD
        this.updateHUD();
      
        // Ê£ÄÊü•ÂÖ≥Âç°ÂÆåÊàê
        this.checkLevelComplete();
    }
  
    // üîß ‰øÆÊîπÊïå‰∫∫ÈÄÉËÑ±Â§ÑÁêÜ
    handleEnemyEscape(escapeData) {
        console.log(`MainScene: Êïå‰∫∫ÈÄÉËÑ±‰∫ã‰ª∂ - ${escapeData.enemyName}`);
      
        // Êâ£Èô§Ë°ÄÈáè
        this.currentHealth -= escapeData.damage;
      
        // Á°Æ‰øùË°ÄÈáè‰∏ç‰Ωé‰∫é0
        if (this.currentHealth < 0) {
            this.currentHealth = 0;
        }
      
        console.log(`MainScene: Êïå‰∫∫ÈÄÉËÑ±Êâ£Ë°Ä ${escapeData.damage}ÔºåÂΩìÂâçË°ÄÈáè: ${this.currentHealth}/${this.maxHealth}`);
      
        // ÂáèÂ∞ëÊïå‰∫∫ËÆ°Êï∞
        this.currentEnemyCount--;
      
        // ËßÜËßâÂèçÈ¶àÊïàÊûú
        this.showDamageEffect(escapeData.damage, 'escape');
      
        // Êõ¥Êñ∞HUD
        this.updateHUD();
      
        // Ê£ÄÊü•Ê∏∏ÊàèÊòØÂê¶ÁªìÊùü
        if (this.currentHealth <= 0) {
            this.gameOver();
        }
    }
  


    // üÜï ‰øÆÊîπÂÖ≥Âç°ÂÆåÊàêÊ£ÄÊü•
    // üÜï ÂÖ≥Âç°ÂÆåÊàêÊ£ÄÊü•ÔºàÊ®™ÁâàÂç∑ËΩ¥ÁâàÊú¨Ôºâ
    checkLevelComplete() {
        if (this.isGameOver || this.isLevelCompleted) return;
      
        const currentTime = this.time.now;
        const survivalTime = currentTime - this.gameStartTime;
      
        // üÜï Ê®™ÁâàÂç∑ËΩ¥ÔºöÊ£ÄÊü•Ë∑ùÁ¶ªÊù°‰ª∂ - Âà∞Ëææ‰∏ñÁïåÂè≥ËæπÁïå
        if (this.player && this.player.x >= 3800) { // Êé•Ëøë4000ÂÉèÁ¥†Êó∂Ëß¶Âèë
            this.completeLevel(`Âà∞ËææÂÖ≥Âç°ÁªàÁÇπ`);
            return;
        }
      
        // Ê£ÄÊü•ÁîüÂ≠òÊó∂Èó¥Êù°‰ª∂
        if (survivalTime >= this.levelCompleteTime) {
            this.completeLevel(`ÁîüÂ≠òÊó∂Èó¥ËææÂà∞${this.levelCompleteTime/1000}Áßí`);
            return;
        }
      
        // Ê£ÄÊü•ÂáªÊùÄÊï∞Êù°‰ª∂
        if (this.killCount >= this.levelCompleteKills) {
            this.completeLevel(`ÂáªÊùÄ${this.levelCompleteKills}‰∏™Êïå‰∫∫`);
            return;
        }
    }

    // üÜï ÂÆåÊàêÂÖ≥Âç°
    completeLevel(reason) {
        if (this.isLevelCompleted) return;
      
        this.isLevelCompleted = true;
        console.log(`MainScene: ÂÖ≥Âç° ${this.currentLevel.name} ÂÆåÊàêÔºÅÂéüÂõ†: ${reason}`);
      
        this.levelEndTime = this.time.now;
        this.levelComplete = true;
      
        // ÂÅúÊ≠¢Êïå‰∫∫ÁîüÊàê
        if (this.enemySpawner) {
            this.enemySpawner.remove();
            this.enemySpawner = null;
        }
      
        // Ê∏ÖÈô§ÊâÄÊúâÊïå‰∫∫ÂíåÂ≠êÂºπ
        this.enemies.clear(true, true);
        this.enemyBullets.clear(true, true);
      
        // ÊòæÁ§∫ÂÖ≥Âç°ÂÆåÊàêÁïåÈù¢
        this.showLevelCompleteScreen(reason);
    }

    // üÜï ÊòæÁ§∫ÂÖ≥Âç°ÂÆåÊàêÁïåÈù¢
    showLevelCompleteScreen(reason) {
        const completeBg = this.add.rectangle(640, 360, 600, 400, 0x000000, 0.9).setScrollFactor(0);
      
        this.add.text(640, 240, 'üéâ ÂÖ≥Âç°ÂÆåÊàêÔºÅüéâ', {
            font: '48px Arial',
            fill: '#00ff00',
            stroke: '#ffffff',
            strokeThickness: 2
        }).setOrigin(0.5).setScrollFactor(0);
      
        this.add.text(640, 300, `${this.currentLevel.name}`, {
            font: '32px Arial',
            fill: '#ffff00',
            stroke: '#000000',
            strokeThickness: 2
        }).setOrigin(0.5).setScrollFactor(0);
      
        this.add.text(640, 340, `ÂÆåÊàêÊù°‰ª∂: ${reason}`, {
            font: '20px Arial',
            fill: '#ffffff'
        }).setOrigin(0.5).setScrollFactor(0);
      
        this.add.text(640, 380, `ÊúÄÁªàÂàÜÊï∞: ${this.score}`, {
            font: '24px Arial',
            fill: '#ffffff'
        }).setOrigin(0.5).setScrollFactor(0);
      
        this.add.text(640, 420, `ÂáªÊùÄÊï∞: ${this.killCount}`, {
            font: '20px Arial',
            fill: '#cccccc'
        }).setOrigin(0.5).setScrollFactor(0);
      
        // ÊåâÈîÆÊèêÁ§∫
        this.add.text(640, 480, 'üèÜ Ê®™ÁâàÂç∑ËΩ¥ÊµãËØïÂÆåÊàêÔºÅüèÜ', {
                font: '24px Arial',
                fill: '#ffd700'
        }).setOrigin(0.5).setScrollFactor(0);
      
        this.add.text(640, 520, 'Êåâ R ÈáçÊñ∞ÂºÄÂßãÊú¨ÂÖ≥', {
            font: '16px Arial',
            fill: '#cccccc'
        }).setOrigin(0.5).setScrollFactor(0);
        
        // Ê≥®ÊÑèÔºöRÈîÆÁõëÂê¨Âô®Â∑≤Âú®create()ÊñπÊ≥ï‰∏≠ËÆæÁΩÆÔºåËøôÈáå‰∏çÈúÄË¶ÅÈáçÂ§çÊ∑ªÂä†
    }

    // üîß Âú®Âú∫ÊôØÈîÄÊØÅÊó∂Ê∏ÖÁêÜ‰∫ã‰ª∂ÁõëÂê¨Âô®
    destroy() {
        // Ê∏ÖÁêÜËß¶Êë∏ÊéßÂà∂
        if (this.touchControls) {
            this.touchControls.destroy();
        }
        
        // üé® Ê∏ÖÁêÜÂÉèÁ¥†Ëâ∫ÊúØÂä®ÁîªÂÆöÊó∂Âô®
        if (this.player && this.player.animationTimer) {
            this.player.animationTimer.destroy();
        }
        
        // üîä Ê∏ÖÁêÜÈü≥ÊïàÁ≥ªÁªü
        if (this.audioManager) {
            this.audioManager.stopBackgroundMusic(); // üÜï ÂÅúÊ≠¢ËÉåÊôØÈü≥‰πê
            this.audioManager.destroy();
        }
        
        // üïê Ê∏ÖÁêÜÊâÄÊúâÂÆöÊó∂Âô®
        if (this.enemySpawner) {
            this.enemySpawner.destroy();
        }
        
        // üí• Ê∏ÖÁêÜÊâÄÊúâÁ≤íÂ≠êÁ≥ªÁªü
        if (this.shootEmitter) {
            this.shootEmitter.destroy();
        }
        if (this.explosionEmitter) {
            this.explosionEmitter.destroy();
        }
        if (this.damageEmitter) {
            this.damageEmitter.destroy();
        }
        if (this.deathEmitter) {
            this.deathEmitter.destroy();
        }
        
        // üéÅ Ê∏ÖÁêÜÈÅìÂÖ∑ÁÆ°ÁêÜÂô®
        if (this.powerUpManager) {
            this.powerUpManager.destroy();
        }
        
        // üèóÔ∏è Ê∏ÖÁêÜÈöúÁ¢çÁâ©ÁÆ°ÁêÜÂô®
        if (this.obstacleManager) {
            this.obstacleManager.destroy();
        }
        
        // üìä Ê∏ÖÁêÜUIÁÆ°ÁêÜÂô®
        if (this.uiManager) {
            this.uiManager.destroy();
        }
        
        // üé® Ê∏ÖÁêÜËÉåÊôØÁÆ°ÁêÜÂô®
        if (this.backgroundManager) {
            this.backgroundManager.destroy();
        }
        
        // üìä Ê∏ÖÁêÜÁªüËÆ°Á≥ªÁªü
        if (window.StatsManager) {
            window.StatsManager.saveStats();
        }
        
        // Ê∏ÖÁêÜËá™ÂÆö‰πâ‰∫ã‰ª∂ÁõëÂê¨Âô®
        this.events.off('enemyDied', this.handleEnemyDeath, this);
        this.events.off('enemyEscaped', this.handleEnemyEscape, this);
        
        // Ê∏ÖÁêÜÈîÆÁõò‰∫ã‰ª∂ÁõëÂê¨Âô®
        this.input.keyboard.off('keydown-R', this.handleRestart, this);
        this.input.keyboard.off('keydown-N', this.nextLevel, this);
        
        // Ê∏ÖÁêÜÂÖ∂‰ªñ‰∫ã‰ª∂ÁõëÂê¨Âô®
        this.input.keyboard.off('keydown-SPACE', this.shoot, this);
        this.input.keyboard.off('keydown-P', this.togglePause, this);
        this.input.keyboard.off('keydown-ONE', () => this.switchWeapon(0), this);
        this.input.keyboard.off('keydown-TWO', () => this.switchWeapon(1), this);
        this.input.keyboard.off('keydown-THREE', () => this.switchWeapon(2), this);
        this.input.keyboard.off('keydown-FOUR', () => this.switchWeapon(3), this);
        this.input.keyboard.off('keydown-FIVE', () => this.switchWeapon(4), this);
        this.input.keyboard.off('keydown-SIX', () => this.switchWeapon(5), this);
        
        super.destroy();
    }

    // ÁéØÂ¢ÉÊïàÊûúÊñπÊ≥ïÔºàÂç†‰ΩçÁ¨¶Ôºâ
    createSandstormEffect() {
        // Ê≤ôÂ∞òÊö¥ÊïàÊûúÂÆûÁé∞
        console.log('MainScene: ÂàõÂª∫Ê≤ôÂ∞òÊö¥ÊïàÊûú');
    }

    createFogEffect() {
        // Ëø∑ÈõæÊïàÊûúÂÆûÁé∞
        console.log('MainScene: ÂàõÂª∫Ëø∑ÈõæÊïàÊûú');
    }

    // üé® Ê∑ªÂä†Áº∫Â§±ÁöÑËæÖÂä©ÁªòÂà∂ÊñπÊ≥ï
    drawCloud(graphics, cloudX, cloudY, cloudSize) {
        // ÁªòÂà∂‰∫ëÊúµÁöÑÂÖ∑‰ΩìÂÆûÁé∞
        for (let i = 0; i < 5; i++) {
            const offsetX = (Math.random() - 0.5) * cloudSize;
            const offsetY = (Math.random() - 0.5) * cloudSize * 0.5;
            graphics.fillCircle(cloudX + offsetX, cloudY + offsetY, cloudSize * 0.3);
        }
    }

    drawHexagon(graphics, x, y, size) {
        graphics.beginPath();
        for (let i = 0; i < 6; i++) {
            const angle = (i / 6) * Math.PI * 2;
            const hx = x + Math.cos(angle) * size;
            const hy = y + Math.sin(angle) * size;
            if (i === 0) graphics.moveTo(hx, hy);
            else graphics.lineTo(hx, hy);
        }
        graphics.closePath();
        graphics.strokePath();
    }

    fillHexagon(graphics, x, y, size) {
        graphics.beginPath();
        for (let i = 0; i < 6; i++) {
            const angle = (i / 6) * Math.PI * 2;
            const hx = x + Math.cos(angle) * size;
            const hy = y + Math.sin(angle) * size;
            if (i === 0) graphics.moveTo(hx, hy);
            else graphics.lineTo(hx, hy);
        }
        graphics.closePath();
        graphics.fillPath();
    }

    createBubblesEffect() {
        // Ê∞îÊ≥°ÊïàÊûúÂÆûÁé∞
        console.log('MainScene: ÂàõÂª∫Ê∞îÊ≥°ÊïàÊûú');
    }

    createStarsEffect() {
        // ÊòüÁ©∫ÊïàÊûúÂÆûÁé∞
        console.log('MainScene: ÂàõÂª∫ÊòüÁ©∫ÊïàÊûú');
    }

    collectPowerUp(player, powerUp) {
        if (powerUp.collect) {
            powerUp.collect();
        }
    }

    updatePowerUpHUD() {
        if (this.powerUpHUDGroup) {
            this.powerUpHUDGroup.clear(true);
        } else {
            this.powerUpHUDGroup = this.add.group();
        }
        const activeBonuses = this.powerUpManager.getActiveBonuses();
        activeBonuses.forEach((bonus, index) => {
            const x = 50;
            const y = 150 + index * 40;
            const remainingTime = Math.max(0, bonus.endTime - Date.now());
            const seconds = Math.ceil(remainingTime / 1000);
            const bg = this.add.rectangle(x, y, 200, 30, 0x000000, 0.6)
                .setOrigin(0, 0.5)
                .setStroke(0xffffff, 1)
                .setScrollFactor(0);
            const text = this.add.text(x + 10, y, `${bonus.symbol} ${bonus.name} ${seconds}s`, {
                fontSize: '14px',
                fill: '#ffffff'
            }).setOrigin(0, 0.5).setScrollFactor(0);
            const progressWidth = 180;
            const progress = remainingTime / bonus.effect.duration;
            const progressBg = this.add.rectangle(x + 10, y + 12, progressWidth, 4, 0x333333)
                .setOrigin(0, 0.5)
                .setScrollFactor(0);
            const progressBar = this.add.rectangle(x + 10, y + 12, progressWidth * progress, 4, 0x00ff00)
                .setOrigin(0, 0.5)
                .setScrollFactor(0);
            this.powerUpHUDGroup.addMultiple([bg, text, progressBg, progressBar]);
        });
        this.powerUpHUDGroup.setDepth(1000);
    }

    switchLevel(levelType) {
        console.log(`üåç ÂàáÊç¢Âà∞ ${levelType} ÂÖ≥Âç°`);
        
        // üÜï Êõ¥Êñ∞ÈöúÁ¢çÁâ©Á≥ªÁªüÂÖ≥Âç°
        if (this.obstacleManager) {
            this.obstacleManager.setLevel(levelType);
            this.obstacleManager.spawnObstacles();
        }
        
        // ... ÂÖ∂‰ªñÂÖ≥Âç°ÂàáÊç¢ÈÄªËæë ...
    }
    
    // üÜï Ê®™ÁâàÂç∑ËΩ¥ÔºöÂ§öÂ±ÇËßÜÂ∑ÆËÉåÊôØÊñπÊ≥ï
    
    // 1. ÁßëÊäÄÁΩëÊ†ºËßÜÂ∑ÆËÉåÊôØ
    generateParallaxTechGridBackground() {
        // ËøúÊôØÂ±ÇÔºàÊªöÂä®ÈÄüÂ∫¶ 0.3Ôºâ
        const farGraphics = this.add.graphics();
        farGraphics.fillStyle(0xe6f3ff);
        farGraphics.fillRect(0, 0, 4000, 720);
        for (let i = 0; i < 10; i++) {
            const alpha = 0.1 - (i * 0.01);
            farGraphics.fillStyle(0xccddff, alpha);
            farGraphics.fillRect(0, i * 72, 4000, 72);
        }
        farGraphics.setDepth(-300);
        farGraphics.setScrollFactor(0.3);
        
        // ‰∏≠ÊôØÂ±ÇÔºàÊªöÂä®ÈÄüÂ∫¶ 0.6Ôºâ
        const midGraphics = this.add.graphics();
        midGraphics.lineStyle(1, 0x99ccff, 0.3);
        const gridSize = 40;
        for (let x = 0; x <= 4000; x += gridSize) {
            midGraphics.beginPath();
            midGraphics.moveTo(x, 0);
            midGraphics.lineTo(x, 720);
            midGraphics.strokePath();
        }
        for (let y = 0; y <= 720; y += gridSize) {
            midGraphics.beginPath();
            midGraphics.moveTo(0, y);
            midGraphics.lineTo(4000, y);
            midGraphics.strokePath();
        }
        midGraphics.setDepth(-200);
        midGraphics.setScrollFactor(0.6);
        
        // ËøëÊôØÂ±ÇÔºàÊªöÂä®ÈÄüÂ∫¶ 1.0Ôºâ
        const nearGraphics = this.add.graphics();
        nearGraphics.fillStyle(0x6699ff, 0.4);
        for (let i = 0; i < 60; i++) {
            const x = Phaser.Math.Between(0, 4000);
            const y = Phaser.Math.Between(0, 720);
            nearGraphics.fillCircle(x, y, 2);
            nearGraphics.lineStyle(1, 0x6699ff, 0.3);
            nearGraphics.beginPath();
            nearGraphics.moveTo(x - 5, y);
            nearGraphics.lineTo(x + 5, y);
            nearGraphics.moveTo(x, y - 5);
            nearGraphics.lineTo(x, y + 5);
            nearGraphics.strokePath();
        }
        nearGraphics.setDepth(-100);
        nearGraphics.setScrollFactor(1.0);
    }
    
    // 2. ‰∫ëÊúµËßÜÂ∑ÆËÉåÊôØ
    generateParallaxCloudBackground() {
        // ËøúÊôØÂ±ÇÔºàÊªöÂä®ÈÄüÂ∫¶ 0.3Ôºâ
        const farGraphics = this.add.graphics();
        farGraphics.fillStyle(0xf0f8ff);
        farGraphics.fillRect(0, 0, 4000, 720);
        for (let i = 0; i < 20; i++) {
            const alpha = 0.05 - (i * 0.002);
            farGraphics.fillStyle(0xe0e6ff, alpha);
            farGraphics.fillRect(0, i * 36, 4000, 36);
        }
        farGraphics.setDepth(-300);
        farGraphics.setScrollFactor(0.3);
        
        // ‰∏≠ÊôØÂ±ÇÔºàÊªöÂä®ÈÄüÂ∫¶ 0.6Ôºâ
        const midGraphics = this.add.graphics();
        midGraphics.fillStyle(0xffffff, 0.4);
        for (let i = 0; i < 30; i++) {
            const cloudX = Phaser.Math.Between(0, 4000);
            const cloudY = Phaser.Math.Between(50, 400);
            const cloudSize = Phaser.Math.Between(40, 100);
            this.drawCloud(midGraphics, cloudX, cloudY, cloudSize);
        }
        midGraphics.setDepth(-200);
        midGraphics.setScrollFactor(0.6);
        
        // ËøëÊôØÂ±ÇÔºàÊªöÂä®ÈÄüÂ∫¶ 1.0Ôºâ
        const nearGraphics = this.add.graphics();
        nearGraphics.fillStyle(0xffffff, 0.6);
        for (let i = 0; i < 20; i++) {
            const cloudX = Phaser.Math.Between(0, 4000);
            const cloudY = Phaser.Math.Between(100, 500);
            const cloudSize = Phaser.Math.Between(30, 80);
            this.drawCloud(nearGraphics, cloudX, cloudY, cloudSize);
        }
        nearGraphics.setDepth(-100);
        nearGraphics.setScrollFactor(1.0);
    }
    
    // 3. ÁîµË∑ØÊùøËßÜÂ∑ÆËÉåÊôØ
    generateParallaxCircuitBackground() {
        // ËøúÊôØÂ±ÇÔºàÊªöÂä®ÈÄüÂ∫¶ 0.3Ôºâ
        const farGraphics = this.add.graphics();
        farGraphics.fillStyle(0xf0fff0);
        farGraphics.fillRect(0, 0, 4000, 720);
        farGraphics.setDepth(-300);
        farGraphics.setScrollFactor(0.3);
        
        // ‰∏≠ÊôØÂ±ÇÔºàÊªöÂä®ÈÄüÂ∫¶ 0.6Ôºâ
        const midGraphics = this.add.graphics();
        midGraphics.lineStyle(2, 0x90ee90, 0.4);
        for (let i = 0; i < 80; i++) {
            const startX = Phaser.Math.Between(0, 4000);
            const startY = Phaser.Math.Between(0, 720);
            const endX = startX + Phaser.Math.Between(-200, 200);
            const endY = startY + Phaser.Math.Between(-200, 200);
            midGraphics.beginPath();
            midGraphics.moveTo(startX, startY);
            midGraphics.lineTo(endX, startY);
            midGraphics.lineTo(endX, endY);
            midGraphics.strokePath();
        }
        midGraphics.setDepth(-200);
        midGraphics.setScrollFactor(0.6);
        
        // ËøëÊôØÂ±ÇÔºàÊªöÂä®ÈÄüÂ∫¶ 1.0Ôºâ
        const nearGraphics = this.add.graphics();
        nearGraphics.fillStyle(0x32cd32, 0.8);
        nearGraphics.lineStyle(1, 0x32cd32, 0.8);
        for (let i = 0; i < 30; i++) {
            const rectX = Phaser.Math.Between(50, 3900);
            const rectY = Phaser.Math.Between(50, 650);
            const rectW = Phaser.Math.Between(20, 60);
            const rectH = Phaser.Math.Between(15, 40);
            nearGraphics.fillRect(rectX, rectY, rectW, rectH);
            nearGraphics.strokeRect(rectX, rectY, rectW, rectH);
        }
        nearGraphics.setDepth(-100);
        nearGraphics.setScrollFactor(1.0);
    }
    
    // 4. ÊòüÁ©∫ËßÜÂ∑ÆËÉåÊôØ
    generateParallaxStarFieldBackground() {
        // ËøúÊôØÂ±ÇÔºàÊªöÂä®ÈÄüÂ∫¶ 0.3Ôºâ
        const farGraphics = this.add.graphics();
        farGraphics.fillStyle(0xf8f8ff);
        farGraphics.fillRect(0, 0, 4000, 720);
        for (let radius = 500; radius > 0; radius -= 50) {
            const alpha = (500 - radius) / 500 * 0.1;
            farGraphics.fillStyle(0xe6e6fa, alpha);
            farGraphics.fillCircle(2000, 360, radius);
        }
        farGraphics.setDepth(-300);
        farGraphics.setScrollFactor(0.3);
        
        // ‰∏≠ÊôØÂ±ÇÔºàÊªöÂä®ÈÄüÂ∫¶ 0.6Ôºâ
        const midGraphics = this.add.graphics();
        for (let i = 0; i < 200; i++) {
            const x = Phaser.Math.Between(0, 4000);
            const y = Phaser.Math.Between(0, 720);
            const size = Phaser.Math.Between(1, 2);
            const alpha = Math.random() * 0.6 + 0.2;
            midGraphics.fillStyle(0xdda0dd, alpha);
            midGraphics.fillCircle(x, y, size);
        }
        midGraphics.setDepth(-200);
        midGraphics.setScrollFactor(0.6);
        
        // ËøëÊôØÂ±ÇÔºàÊªöÂä®ÈÄüÂ∫¶ 1.0Ôºâ
        const nearGraphics = this.add.graphics();
        for (let i = 0; i < 100; i++) {
            const x = Phaser.Math.Between(0, 4000);
            const y = Phaser.Math.Between(0, 720);
            const size = Phaser.Math.Between(2, 4);
            const alpha = Math.random() * 0.8 + 0.2;
            nearGraphics.fillStyle(0xffffff, alpha);
            nearGraphics.fillCircle(x, y, size);
            if (size >= 3) {
                nearGraphics.lineStyle(1, 0xffffff, alpha * 0.5);
                nearGraphics.beginPath();
                nearGraphics.moveTo(x - size * 2, y);
                nearGraphics.lineTo(x + size * 2, y);
                nearGraphics.moveTo(x, y - size * 2);
                nearGraphics.lineTo(x, y + size * 2);
                nearGraphics.strokePath();
            }
        }
        nearGraphics.setDepth(-100);
        nearGraphics.setScrollFactor(1.0);
    }
    
    // 5. ÂÖ≠ËßíÂΩ¢ËßÜÂ∑ÆËÉåÊôØ
    generateParallaxHexagonBackground() {
        // ËøúÊôØÂ±ÇÔºàÊªöÂä®ÈÄüÂ∫¶ 0.3Ôºâ
        const farGraphics = this.add.graphics();
        farGraphics.fillStyle(0xf5f5f5);
        farGraphics.fillRect(0, 0, 4000, 720);
        farGraphics.setDepth(-300);
        farGraphics.setScrollFactor(0.3);
        
        // ‰∏≠ÊôØÂ±ÇÔºàÊªöÂä®ÈÄüÂ∫¶ 0.6Ôºâ
        const midGraphics = this.add.graphics();
        const hexSize = 40;
        const hexWidth = hexSize * Math.sqrt(3);
        const hexHeight = hexSize * 2;
        midGraphics.lineStyle(1, 0xd3d3d3, 0.6);
        for (let row = 0; row < Math.ceil(720 / (hexHeight * 0.75)) + 1; row++) {
            for (let col = 0; col < Math.ceil(4000 / hexWidth) + 1; col++) {
                const x = col * hexWidth + (row % 2) * (hexWidth / 2);
                const y = row * hexHeight * 0.75;
                this.drawHexagon(midGraphics, x, y, hexSize);
            }
        }
        midGraphics.setDepth(-200);
        midGraphics.setScrollFactor(0.6);
        
        // ËøëÊôØÂ±ÇÔºàÊªöÂä®ÈÄüÂ∫¶ 1.0Ôºâ
        const nearGraphics = this.add.graphics();
        nearGraphics.fillStyle(0xe0e0e0, 0.5);
        for (let i = 0; i < 60; i++) {
            const randomRow = Phaser.Math.Between(0, Math.ceil(720 / (hexHeight * 0.75)));
            const randomCol = Phaser.Math.Between(0, Math.ceil(4000 / hexWidth));
            const x = randomCol * hexWidth + (randomRow % 2) * (hexWidth / 2);
            const y = randomRow * hexHeight * 0.75;
            this.fillHexagon(nearGraphics, x, y, hexSize);
        }
        nearGraphics.setDepth(-100);
        nearGraphics.setScrollFactor(1.0);
    }
    
    // 6. Ê≥¢Êµ™ËßÜÂ∑ÆËÉåÊôØ
    generateParallaxWaveBackground() {
        // ËøúÊôØÂ±ÇÔºàÊªöÂä®ÈÄüÂ∫¶ 0.3Ôºâ
        const farGraphics = this.add.graphics();
        farGraphics.fillStyle(0xf0ffff);
        farGraphics.fillRect(0, 0, 4000, 720);
        for (let i = 0; i < 15; i++) {
            const alpha = 0.08 - (i * 0.005);
            farGraphics.fillStyle(0xe0f6ff, alpha);
            farGraphics.fillRect(0, i * 48, 4000, 48);
        }
        farGraphics.setDepth(-300);
        farGraphics.setScrollFactor(0.3);
        
        // ‰∏≠ÊôØÂ±ÇÔºàÊªöÂä®ÈÄüÂ∫¶ 0.6Ôºâ
        const midGraphics = this.add.graphics();
        const waveColors = [0xb0e0e6, 0x87ceeb, 0x87cefa];
        const waveAlphas = [0.2, 0.15, 0.1];
        for (let layer = 0; layer < 3; layer++) {
            midGraphics.fillStyle(waveColors[layer], waveAlphas[layer]);
            const amplitude = 20 + layer * 15;
            const frequency = 0.008 + layer * 0.003;
            for (let x = 0; x < 4000; x += 5) {
                const y = 360 + Math.sin(x * frequency) * amplitude;
                midGraphics.fillCircle(x, y, 3);
            }
        }
        midGraphics.setDepth(-200);
        midGraphics.setScrollFactor(0.6);
        
        // ËøëÊôØÂ±ÇÔºàÊªöÂä®ÈÄüÂ∫¶ 1.0Ôºâ
        const nearGraphics = this.add.graphics();
        nearGraphics.fillStyle(0x00bfff, 0.3);
        for (let i = 0; i < 50; i++) {
            const x = Phaser.Math.Between(0, 4000);
            const y = Phaser.Math.Between(100, 620);
            const size = Phaser.Math.Between(10, 30);
            nearGraphics.fillCircle(x, y, size);
        }
        nearGraphics.setDepth(-100);
        nearGraphics.setScrollFactor(1.0);
    }
}

// üÜï ÂØºÂá∫Âà∞ÂÖ®Â±Ä‰ΩúÁî®Âüü
window.MainScene = MainScene;
console.log('‚úÖ MainScene.js Â∑≤Âä†ËΩΩ'); 